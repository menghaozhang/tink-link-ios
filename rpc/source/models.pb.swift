// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: models.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum MarketStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case beta // = 1
  case disabled // = 2
  case enabled // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .beta
    case 2: self = .disabled
    case 3: self = .enabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .beta: return 1
    case .disabled: return 2
    case .enabled: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MarketStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MarketStatus] = [
    .unknown,
    .beta,
    .disabled,
    .enabled,
  ]
}

#endif  // swift(>=4.2)

public enum PeriodDateBreakType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case monthly // = 1
  case monthlyAdjusted // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .monthly
    case 2: self = .monthlyAdjusted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .monthly: return 1
    case .monthlyAdjusted: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PeriodDateBreakType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PeriodDateBreakType] = [
    .unknown,
    .monthly,
    .monthlyAdjusted,
  ]
}

#endif  // swift(>=4.2)

public enum PeriodMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case daily // = 1
  case monthly // = 2
  case weekly // = 3
  case yearly // = 4
  case all // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .daily
    case 2: self = .monthly
    case 3: self = .weekly
    case 4: self = .yearly
    case 5: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .daily: return 1
    case .monthly: return 2
    case .weekly: return 3
    case .yearly: return 4
    case .all: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PeriodMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PeriodMode] = [
    .unknown,
    .daily,
    .monthly,
    .weekly,
    .yearly,
    .all,
  ]
}

#endif  // swift(>=4.2)

public enum BankIdAuthenticationStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case authenticated // = 1
  case authenticationError // = 2
  case awaitingBankidAuthentication // = 3
  case noUser // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .authenticated
    case 2: self = .authenticationError
    case 3: self = .awaitingBankidAuthentication
    case 4: self = .noUser
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .authenticated: return 1
    case .authenticationError: return 2
    case .awaitingBankidAuthentication: return 3
    case .noUser: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BankIdAuthenticationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BankIdAuthenticationStatus] = [
    .unknown,
    .authenticated,
    .authenticationError,
    .awaitingBankidAuthentication,
    .noUser,
  ]
}

#endif  // swift(>=4.2)

public enum AuthenticationStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case authenticated // = 1
  case authenticationError // = 2
  case noUser // = 4
  case userBlocked // = 5
  case authenticatedUnauthorizedDevice // = 6
  case authenticationErrorUnauthorizedDevice // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .authenticated
    case 2: self = .authenticationError
    case 4: self = .noUser
    case 5: self = .userBlocked
    case 6: self = .authenticatedUnauthorizedDevice
    case 7: self = .authenticationErrorUnauthorizedDevice
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .authenticated: return 1
    case .authenticationError: return 2
    case .noUser: return 4
    case .userBlocked: return 5
    case .authenticatedUnauthorizedDevice: return 6
    case .authenticationErrorUnauthorizedDevice: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AuthenticationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [AuthenticationStatus] = [
    .unknown,
    .authenticated,
    .authenticationError,
    .noUser,
    .userBlocked,
    .authenticatedUnauthorizedDevice,
    .authenticationErrorUnauthorizedDevice,
  ]
}

#endif  // swift(>=4.2)

public enum AuthenticationKeyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case keyTypeUnknown // = 0
  case keyTypeRsa // = 1
  case keyTypeEcdsa // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .keyTypeUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .keyTypeUnknown
    case 1: self = .keyTypeRsa
    case 2: self = .keyTypeEcdsa
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .keyTypeUnknown: return 0
    case .keyTypeRsa: return 1
    case .keyTypeEcdsa: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AuthenticationKeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [AuthenticationKeyType] = [
    .keyTypeUnknown,
    .keyTypeRsa,
    .keyTypeEcdsa,
  ]
}

#endif  // swift(>=4.2)

public enum AuthenticationSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case touchid // = 1
  case fingerprint // = 2
  case faceid // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .touchid
    case 2: self = .fingerprint
    case 3: self = .faceid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .touchid: return 1
    case .fingerprint: return 2
    case .faceid: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AuthenticationSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [AuthenticationSource] = [
    .unknown,
    .touchid,
    .fingerprint,
    .faceid,
  ]
}

#endif  // swift(>=4.2)

public enum IdentityAnswerKey: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case ok // = 1
  case fraudulent // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ok
    case 2: self = .fraudulent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ok: return 1
    case .fraudulent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension IdentityAnswerKey: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [IdentityAnswerKey] = [
    .unknown,
    .ok,
    .fraudulent,
  ]
}

#endif  // swift(>=4.2)

public enum ConsentAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case accepted // = 1
  case declined // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .accepted
    case 2: self = .declined
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .accepted: return 1
    case .declined: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ConsentAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ConsentAction] = [
    .unknown,
    .accepted,
    .declined,
  ]
}

#endif  // swift(>=4.2)

public enum SmsOtpStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case correct // = 1
  case incorrect // = 2
  case expired // = 3
  case tooManyAttempts // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .correct
    case 2: self = .incorrect
    case 3: self = .expired
    case 4: self = .tooManyAttempts
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .correct: return 1
    case .incorrect: return 2
    case .expired: return 3
    case .tooManyAttempts: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SmsOtpStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SmsOtpStatus] = [
    .unknown,
    .correct,
    .incorrect,
    .expired,
    .tooManyAttempts,
  ]
}

#endif  // swift(>=4.2)

public enum RateAppStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case clickedIgnore // = 1
  case clickedRateInStore // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .clickedIgnore
    case 2: self = .clickedRateInStore
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .clickedIgnore: return 1
    case .clickedRateInStore: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RateAppStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [RateAppStatus] = [
    .unknown,
    .clickedIgnore,
    .clickedRateInStore,
  ]
}

#endif  // swift(>=4.2)

public enum AuthenticationMethod: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case bankid // = 1
  case emailAndPassword // = 2
  case smsOtpAndPin6 // = 3
  case phoneNumberAndPin6 // = 4
  case abnAmroPin5 // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .bankid
    case 2: self = .emailAndPassword
    case 3: self = .smsOtpAndPin6
    case 4: self = .phoneNumberAndPin6
    case 5: self = .abnAmroPin5
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .bankid: return 1
    case .emailAndPassword: return 2
    case .smsOtpAndPin6: return 3
    case .phoneNumberAndPin6: return 4
    case .abnAmroPin5: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AuthenticationMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [AuthenticationMethod] = [
    .unknown,
    .bankid,
    .emailAndPassword,
    .smsOtpAndPin6,
    .phoneNumberAndPin6,
    .abnAmroPin5,
  ]
}

#endif  // swift(>=4.2)

public enum ApplicationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case switchMortgageProvider // = 1
  case openSavingsAccount // = 2
  case residenceValuation // = 3
  case solicitUnsecuredLoans // = 4
  case acceptUnsecuredLoans // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .switchMortgageProvider
    case 2: self = .openSavingsAccount
    case 3: self = .residenceValuation
    case 4: self = .solicitUnsecuredLoans
    case 5: self = .acceptUnsecuredLoans
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .switchMortgageProvider: return 1
    case .openSavingsAccount: return 2
    case .residenceValuation: return 3
    case .solicitUnsecuredLoans: return 4
    case .acceptUnsecuredLoans: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ApplicationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ApplicationType] = [
    .unknown,
    .switchMortgageProvider,
    .openSavingsAccount,
    .residenceValuation,
    .solicitUnsecuredLoans,
    .acceptUnsecuredLoans,
  ]
}

#endif  // swift(>=4.2)

public enum ApplicationFieldType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case checkbox // = 1
  case date // = 2
  case email // = 3
  case hidden // = 4
  case multiSelect // = 5
  case number // = 6
  case numeric // = 7
  case select // = 8
  case signature // = 9
  case text // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .checkbox
    case 2: self = .date
    case 3: self = .email
    case 4: self = .hidden
    case 5: self = .multiSelect
    case 6: self = .number
    case 7: self = .numeric
    case 8: self = .select
    case 9: self = .signature
    case 10: self = .text
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .checkbox: return 1
    case .date: return 2
    case .email: return 3
    case .hidden: return 4
    case .multiSelect: return 5
    case .number: return 6
    case .numeric: return 7
    case .select: return 8
    case .signature: return 9
    case .text: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ApplicationFieldType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ApplicationFieldType] = [
    .unknown,
    .checkbox,
    .date,
    .email,
    .hidden,
    .multiSelect,
    .number,
    .numeric,
    .select,
    .signature,
    .text,
  ]
}

#endif  // swift(>=4.2)

public enum ApplicationStatusKey: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case applicationStatusUnknown // = 0
  case applicationStatusCreated // = 1
  case applicationStatusInProgress // = 2
  case applicationStatusDeleted // = 3
  case applicationStatusError // = 4
  case applicationStatusExpired // = 5
  case applicationStatusDisqualified // = 6
  case applicationStatusCompleted // = 7
  case applicationStatusSigned // = 8
  case applicationStatusSupplementalInformationRequired // = 9
  case applicationStatusRejected // = 10
  case applicationStatusApproved // = 11
  case applicationStatusAborted // = 12
  case applicationStatusExecuted // = 13
  case applicationStatusPending // = 14
  case UNRECOGNIZED(Int)

  public init() {
    self = .applicationStatusUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .applicationStatusUnknown
    case 1: self = .applicationStatusCreated
    case 2: self = .applicationStatusInProgress
    case 3: self = .applicationStatusDeleted
    case 4: self = .applicationStatusError
    case 5: self = .applicationStatusExpired
    case 6: self = .applicationStatusDisqualified
    case 7: self = .applicationStatusCompleted
    case 8: self = .applicationStatusSigned
    case 9: self = .applicationStatusSupplementalInformationRequired
    case 10: self = .applicationStatusRejected
    case 11: self = .applicationStatusApproved
    case 12: self = .applicationStatusAborted
    case 13: self = .applicationStatusExecuted
    case 14: self = .applicationStatusPending
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .applicationStatusUnknown: return 0
    case .applicationStatusCreated: return 1
    case .applicationStatusInProgress: return 2
    case .applicationStatusDeleted: return 3
    case .applicationStatusError: return 4
    case .applicationStatusExpired: return 5
    case .applicationStatusDisqualified: return 6
    case .applicationStatusCompleted: return 7
    case .applicationStatusSigned: return 8
    case .applicationStatusSupplementalInformationRequired: return 9
    case .applicationStatusRejected: return 10
    case .applicationStatusApproved: return 11
    case .applicationStatusAborted: return 12
    case .applicationStatusExecuted: return 13
    case .applicationStatusPending: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ApplicationStatusKey: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ApplicationStatusKey] = [
    .applicationStatusUnknown,
    .applicationStatusCreated,
    .applicationStatusInProgress,
    .applicationStatusDeleted,
    .applicationStatusError,
    .applicationStatusExpired,
    .applicationStatusDisqualified,
    .applicationStatusCompleted,
    .applicationStatusSigned,
    .applicationStatusSupplementalInformationRequired,
    .applicationStatusRejected,
    .applicationStatusApproved,
    .applicationStatusAborted,
    .applicationStatusExecuted,
    .applicationStatusPending,
  ]
}

#endif  // swift(>=4.2)

public enum ApplicationFormStatusKey: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case applicationFormStatusUnknown // = 0
  case applicationFormStatusCreated // = 1
  case applicationFormStatusCompleted // = 2
  case applicationFormStatusInProgress // = 3
  case applicationFormStatusError // = 4
  case applicationFormStatusDisqualified // = 5
  case applicationFormStatusAutoSaved // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .applicationFormStatusUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .applicationFormStatusUnknown
    case 1: self = .applicationFormStatusCreated
    case 2: self = .applicationFormStatusCompleted
    case 3: self = .applicationFormStatusInProgress
    case 4: self = .applicationFormStatusError
    case 5: self = .applicationFormStatusDisqualified
    case 6: self = .applicationFormStatusAutoSaved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .applicationFormStatusUnknown: return 0
    case .applicationFormStatusCreated: return 1
    case .applicationFormStatusCompleted: return 2
    case .applicationFormStatusInProgress: return 3
    case .applicationFormStatusError: return 4
    case .applicationFormStatusDisqualified: return 5
    case .applicationFormStatusAutoSaved: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ApplicationFormStatusKey: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ApplicationFormStatusKey] = [
    .applicationFormStatusUnknown,
    .applicationFormStatusCreated,
    .applicationFormStatusCompleted,
    .applicationFormStatusInProgress,
    .applicationFormStatusError,
    .applicationFormStatusDisqualified,
    .applicationFormStatusAutoSaved,
  ]
}

#endif  // swift(>=4.2)

public enum InsightGroup: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case groupUnknown // = 0
  case groupEducating // = 1
  case groupEncouraging // = 2
  case groupFunFact // = 3
  case groupProductSuggest // = 4
  case groupPromotion // = 5
  case groupReminder // = 6
  case groupSourceData // = 7
  case groupSuggestion // = 8
  case groupSummary // = 9
  case groupWarning // = 10
  case groupBudget // = 11
  case groupAccount // = 12
  case groupCategorization // = 13
  case groupCredentials // = 14
  case groupInvoice // = 15
  case groupFraud // = 16
  case groupLeftToSpend // = 17
  case UNRECOGNIZED(Int)

  public init() {
    self = .groupUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .groupUnknown
    case 1: self = .groupEducating
    case 2: self = .groupEncouraging
    case 3: self = .groupFunFact
    case 4: self = .groupProductSuggest
    case 5: self = .groupPromotion
    case 6: self = .groupReminder
    case 7: self = .groupSourceData
    case 8: self = .groupSuggestion
    case 9: self = .groupSummary
    case 10: self = .groupWarning
    case 11: self = .groupBudget
    case 12: self = .groupAccount
    case 13: self = .groupCategorization
    case 14: self = .groupCredentials
    case 15: self = .groupInvoice
    case 16: self = .groupFraud
    case 17: self = .groupLeftToSpend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .groupUnknown: return 0
    case .groupEducating: return 1
    case .groupEncouraging: return 2
    case .groupFunFact: return 3
    case .groupProductSuggest: return 4
    case .groupPromotion: return 5
    case .groupReminder: return 6
    case .groupSourceData: return 7
    case .groupSuggestion: return 8
    case .groupSummary: return 9
    case .groupWarning: return 10
    case .groupBudget: return 11
    case .groupAccount: return 12
    case .groupCategorization: return 13
    case .groupCredentials: return 14
    case .groupInvoice: return 15
    case .groupFraud: return 16
    case .groupLeftToSpend: return 17
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension InsightGroup: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [InsightGroup] = [
    .groupUnknown,
    .groupEducating,
    .groupEncouraging,
    .groupFunFact,
    .groupProductSuggest,
    .groupPromotion,
    .groupReminder,
    .groupSourceData,
    .groupSuggestion,
    .groupSummary,
    .groupWarning,
    .groupBudget,
    .groupAccount,
    .groupCategorization,
    .groupCredentials,
    .groupInvoice,
    .groupFraud,
    .groupLeftToSpend,
  ]
}

#endif  // swift(>=4.2)

public enum SortType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case score // = 1
  case date // = 2
  case account // = 3
  case description_ // = 4
  case amount // = 5
  case category // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .score
    case 2: self = .date
    case 3: self = .account
    case 4: self = .description_
    case 5: self = .amount
    case 6: self = .category
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .score: return 1
    case .date: return 2
    case .account: return 3
    case .description_: return 4
    case .amount: return 5
    case .category: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SortType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SortType] = [
    .unknown,
    .score,
    .date,
    .account,
    .description_,
    .amount,
    .category,
  ]
}

#endif  // swift(>=4.2)

public enum OrderType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case asc // = 1
  case desc // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .asc
    case 2: self = .desc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .asc: return 1
    case .desc: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension OrderType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [OrderType] = [
    .unknown,
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public enum Theme: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case light // = 1
  case black // = 2
  case dark // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .light
    case 2: self = .black
    case 3: self = .dark
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .light: return 1
    case .black: return 2
    case .dark: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Theme: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Theme] = [
    .unknown,
    .light,
    .black,
    .dark,
  ]
}

#endif  // swift(>=4.2)

public struct Credential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var providerName: String {
    get {return _storage._providerName}
    set {_uniqueStorage()._providerName = newValue}
  }

  public var type: Credential.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var status: Credential.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var statusPayload: String {
    get {return _storage._statusPayload}
    set {_uniqueStorage()._statusPayload = newValue}
  }

  public var statusUpdated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._statusUpdated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._statusUpdated = newValue}
  }
  /// Returns true if `statusUpdated` has been explicitly set.
  public var hasStatusUpdated: Bool {return _storage._statusUpdated != nil}
  /// Clears the value of `statusUpdated`. Subsequent reads from it will return its default value.
  public mutating func clearStatusUpdated() {_uniqueStorage()._statusUpdated = nil}

  public var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  public var hasUpdated: Bool {return _storage._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  public mutating func clearUpdated() {_uniqueStorage()._updated = nil}

  public var fields: Dictionary<String,String> {
    get {return _storage._fields}
    set {_uniqueStorage()._fields = newValue}
  }

  public var supplementalInformationFields: [ProviderFieldSpecification] {
    get {return _storage._supplementalInformationFields}
    set {_uniqueStorage()._supplementalInformationFields = newValue}
  }

  public var thirdPartyAppAuthentication: ThirdPartyAppAuthentication {
    get {return _storage._thirdPartyAppAuthentication ?? ThirdPartyAppAuthentication()}
    set {_uniqueStorage()._thirdPartyAppAuthentication = newValue}
  }
  /// Returns true if `thirdPartyAppAuthentication` has been explicitly set.
  public var hasThirdPartyAppAuthentication: Bool {return _storage._thirdPartyAppAuthentication != nil}
  /// Clears the value of `thirdPartyAppAuthentication`. Subsequent reads from it will return its default value.
  public mutating func clearThirdPartyAppAuthentication() {_uniqueStorage()._thirdPartyAppAuthentication = nil}

  public var sessionExpiryDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._sessionExpiryDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._sessionExpiryDate = newValue}
  }
  /// Returns true if `sessionExpiryDate` has been explicitly set.
  public var hasSessionExpiryDate: Bool {return _storage._sessionExpiryDate != nil}
  /// Clears the value of `sessionExpiryDate`. Subsequent reads from it will return its default value.
  public mutating func clearSessionExpiryDate() {_uniqueStorage()._sessionExpiryDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case created // = 1
    case authenticating // = 2
    case updating // = 3
    case updated // = 4
    case temporaryError // = 5
    case authenticationError // = 6
    case permanentError // = 7

    /// Will be deprecated and replaced by "STATUS_AWAITING_THIRD_PARTY_APP_AUTHENTICATION".
    case awaitingMobileBankidAuthentication // = 8
    case awaitingSupplementalInformation // = 9
    case disabled // = 10
    case awaitingThirdPartyAppAuthentication // = 11
    case sessionExpired // = 12
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .created
      case 2: self = .authenticating
      case 3: self = .updating
      case 4: self = .updated
      case 5: self = .temporaryError
      case 6: self = .authenticationError
      case 7: self = .permanentError
      case 8: self = .awaitingMobileBankidAuthentication
      case 9: self = .awaitingSupplementalInformation
      case 10: self = .disabled
      case 11: self = .awaitingThirdPartyAppAuthentication
      case 12: self = .sessionExpired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .created: return 1
      case .authenticating: return 2
      case .updating: return 3
      case .updated: return 4
      case .temporaryError: return 5
      case .authenticationError: return 6
      case .permanentError: return 7
      case .awaitingMobileBankidAuthentication: return 8
      case .awaitingSupplementalInformation: return 9
      case .disabled: return 10
      case .awaitingThirdPartyAppAuthentication: return 11
      case .sessionExpired: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case password // = 1

    /// Will be deprecated and replaced by "TYPE_THIRD_PARTY_AUTHENTICATION".
    case mobileBankid // = 2
    case keyfob // = 3
    case fraud // = 4
    case thirdPartyAuthentication // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .password
      case 2: self = .mobileBankid
      case 3: self = .keyfob
      case 4: self = .fraud
      case 5: self = .thirdPartyAuthentication
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .password: return 1
      case .mobileBankid: return 2
      case .keyfob: return 3
      case .fraud: return 4
      case .thirdPartyAuthentication: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Credential.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Credential.Status] = [
    .unknown,
    .created,
    .authenticating,
    .updating,
    .updated,
    .temporaryError,
    .authenticationError,
    .permanentError,
    .awaitingMobileBankidAuthentication,
    .awaitingSupplementalInformation,
    .disabled,
    .awaitingThirdPartyAppAuthentication,
    .sessionExpired,
  ]
}

extension Credential.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Credential.TypeEnum] = [
    .unknown,
    .password,
    .mobileBankid,
    .keyfob,
    .fraud,
    .thirdPartyAuthentication,
  ]
}

#endif  // swift(>=4.2)

public struct Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var balance: CurrencyDenominatedAmount {
    get {return _storage._balance ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var accountNumber: String {
    get {return _storage._accountNumber}
    set {_uniqueStorage()._accountNumber = newValue}
  }

  public var credentialID: String {
    get {return _storage._credentialID}
    set {_uniqueStorage()._credentialID = newValue}
  }

  public var excluded: Bool {
    get {return _storage._excluded}
    set {_uniqueStorage()._excluded = newValue}
  }

  public var favored: Bool {
    get {return _storage._favored}
    set {_uniqueStorage()._favored = newValue}
  }

  public var transactional: Bool {
    get {return _storage._transactional}
    set {_uniqueStorage()._transactional = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var ownership: ExactNumber {
    get {return _storage._ownership ?? ExactNumber()}
    set {_uniqueStorage()._ownership = newValue}
  }
  /// Returns true if `ownership` has been explicitly set.
  public var hasOwnership: Bool {return _storage._ownership != nil}
  /// Clears the value of `ownership`. Subsequent reads from it will return its default value.
  public mutating func clearOwnership() {_uniqueStorage()._ownership = nil}

  public var type: Account.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var images: Images {
    get {return _storage._images ?? Images()}
    set {_uniqueStorage()._images = newValue}
  }
  /// Returns true if `images` has been explicitly set.
  public var hasImages: Bool {return _storage._images != nil}
  /// Clears the value of `images`. Subsequent reads from it will return its default value.
  public mutating func clearImages() {_uniqueStorage()._images = nil}

  public var closed: Bool {
    get {return _storage._closed}
    set {_uniqueStorage()._closed = newValue}
  }

  public var identifiers: [String] {
    get {return _storage._identifiers}
    set {_uniqueStorage()._identifiers = newValue}
  }

  public var exclusionType: Account.Exclusion {
    get {return _storage._exclusionType}
    set {_uniqueStorage()._exclusionType = newValue}
  }

  public var flags: [Account.AccountFlag] {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case checking // = 1
    case savings // = 2
    case investment // = 3
    case mortgage // = 4
    case creditCard // = 5
    case loan // = 6
    case dummy // = 7
    case pension // = 8
    case other // = 9
    case external // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .checking
      case 2: self = .savings
      case 3: self = .investment
      case 4: self = .mortgage
      case 5: self = .creditCard
      case 6: self = .loan
      case 7: self = .dummy
      case 8: self = .pension
      case 9: self = .other
      case 10: self = .external
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .checking: return 1
      case .savings: return 2
      case .investment: return 3
      case .mortgage: return 4
      case .creditCard: return 5
      case .loan: return 6
      case .dummy: return 7
      case .pension: return 8
      case .other: return 9
      case .external: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Exclusion: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unkown // = 0
    case aggregation // = 4
    case pfmAndSearch // = 1
    case pfmData // = 2
    case none // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unkown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unkown
      case 1: self = .pfmAndSearch
      case 2: self = .pfmData
      case 3: self = .none
      case 4: self = .aggregation
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unkown: return 0
      case .pfmAndSearch: return 1
      case .pfmData: return 2
      case .none: return 3
      case .aggregation: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum AccountFlag: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case business // = 1
    case mandate // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .business
      case 2: self = .mandate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .business: return 1
      case .mandate: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Account.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Account.TypeEnum] = [
    .unknown,
    .checking,
    .savings,
    .investment,
    .mortgage,
    .creditCard,
    .loan,
    .dummy,
    .pension,
    .other,
    .external,
  ]
}

extension Account.Exclusion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Account.Exclusion] = [
    .unkown,
    .aggregation,
    .pfmAndSearch,
    .pfmData,
    .none,
  ]
}

extension Account.AccountFlag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Account.AccountFlag] = [
    .unknown,
    .business,
    .mandate,
  ]
}

#endif  // swift(>=4.2)

public struct Tag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  public var amount: CurrencyDenominatedAmount {
    get {return _storage._amount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var categoryCode: String {
    get {return _storage._categoryCode}
    set {_uniqueStorage()._categoryCode = newValue}
  }

  public var originalAmount: CurrencyDenominatedAmount {
    get {return _storage._originalAmount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._originalAmount = newValue}
  }
  /// Returns true if `originalAmount` has been explicitly set.
  public var hasOriginalAmount: Bool {return _storage._originalAmount != nil}
  /// Clears the value of `originalAmount`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalAmount() {_uniqueStorage()._originalAmount = nil}

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var notes: String {
    get {return _storage._notes}
    set {_uniqueStorage()._notes = newValue}
  }

  public var tags: [Tag] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var originalDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._originalDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._originalDate = newValue}
  }
  /// Returns true if `originalDate` has been explicitly set.
  public var hasOriginalDate: Bool {return _storage._originalDate != nil}
  /// Clears the value of `originalDate`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalDate() {_uniqueStorage()._originalDate = nil}

  public var originalDescription: String {
    get {return _storage._originalDescription}
    set {_uniqueStorage()._originalDescription = newValue}
  }

  public var details: Transaction.TransactionDetails {
    get {return _storage._details ?? Transaction.TransactionDetails()}
    set {_uniqueStorage()._details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  public var hasDetails: Bool {return _storage._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  public mutating func clearDetails() {_uniqueStorage()._details = nil}

  public var pending: Bool {
    get {return _storage._pending}
    set {_uniqueStorage()._pending = newValue}
  }

  public var upcoming: Bool {
    get {return _storage._upcoming}
    set {_uniqueStorage()._upcoming = newValue}
  }

  public var type: Transaction.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var secondaryDescription: String {
    get {return _storage._secondaryDescription}
    set {_uniqueStorage()._secondaryDescription = newValue}
  }

  public var inserted: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._inserted ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._inserted = newValue}
  }
  /// Returns true if `inserted` has been explicitly set.
  public var hasInserted: Bool {return _storage._inserted != nil}
  /// Clears the value of `inserted`. Subsequent reads from it will return its default value.
  public mutating func clearInserted() {_uniqueStorage()._inserted = nil}

  public var parts: [Transaction.Part] {
    get {return _storage._parts}
    set {_uniqueStorage()._parts = newValue}
  }

  public var dispensableAmount: CurrencyDenominatedAmount {
    get {return _storage._dispensableAmount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._dispensableAmount = newValue}
  }
  /// Returns true if `dispensableAmount` has been explicitly set.
  public var hasDispensableAmount: Bool {return _storage._dispensableAmount != nil}
  /// Clears the value of `dispensableAmount`. Subsequent reads from it will return its default value.
  public mutating func clearDispensableAmount() {_uniqueStorage()._dispensableAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case `default` // = 1
    case creditCard // = 2
    case payment // = 3
    case transfer // = 4
    case withdrawal // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .default
      case 2: self = .creditCard
      case 3: self = .payment
      case 4: self = .transfer
      case 5: self = .withdrawal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .default: return 1
      case .creditCard: return 2
      case .payment: return 3
      case .transfer: return 4
      case .withdrawal: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct TransactionDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Mapping of fields coming from the payload
    public var transferID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Part {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    public var amount: CurrencyDenominatedAmount {
      get {return _storage._amount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    public var hasAmount: Bool {return _storage._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    public mutating func clearAmount() {_uniqueStorage()._amount = nil}

    public var categoryCode: String {
      get {return _storage._categoryCode}
      set {_uniqueStorage()._categoryCode = newValue}
    }

    public var counterpart: Transaction.Counterpart {
      get {return _storage._counterpart ?? Transaction.Counterpart()}
      set {_uniqueStorage()._counterpart = newValue}
    }
    /// Returns true if `counterpart` has been explicitly set.
    public var hasCounterpart: Bool {return _storage._counterpart != nil}
    /// Clears the value of `counterpart`. Subsequent reads from it will return its default value.
    public mutating func clearCounterpart() {_uniqueStorage()._counterpart = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Counterpart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    public var transactionID: String {
      get {return _storage._transactionID}
      set {_uniqueStorage()._transactionID = newValue}
    }

    public var transactionAmount: CurrencyDenominatedAmount {
      get {return _storage._transactionAmount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._transactionAmount = newValue}
    }
    /// Returns true if `transactionAmount` has been explicitly set.
    public var hasTransactionAmount: Bool {return _storage._transactionAmount != nil}
    /// Clears the value of `transactionAmount`. Subsequent reads from it will return its default value.
    public mutating func clearTransactionAmount() {_uniqueStorage()._transactionAmount = nil}

    public var transactionDescription: String {
      get {return _storage._transactionDescription}
      set {_uniqueStorage()._transactionDescription = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Transaction.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Transaction.TypeEnum] = [
    .unknown,
    .default,
    .creditCard,
    .payment,
    .transfer,
    .withdrawal,
  ]
}

#endif  // swift(>=4.2)

public struct Provider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  public var type: Provider.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var status: Provider.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var credentialType: Credential.TypeEnum {
    get {return _storage._credentialType}
    set {_uniqueStorage()._credentialType = newValue}
  }

  public var helpText: String {
    get {return _storage._helpText}
    set {_uniqueStorage()._helpText = newValue}
  }

  public var popular: Bool {
    get {return _storage._popular}
    set {_uniqueStorage()._popular = newValue}
  }

  public var fields: [ProviderFieldSpecification] {
    get {return _storage._fields}
    set {_uniqueStorage()._fields = newValue}
  }

  public var groupDisplayName: String {
    get {return _storage._groupDisplayName}
    set {_uniqueStorage()._groupDisplayName = newValue}
  }

  public var images: Images {
    get {return _storage._images ?? Images()}
    set {_uniqueStorage()._images = newValue}
  }
  /// Returns true if `images` has been explicitly set.
  public var hasImages: Bool {return _storage._images != nil}
  /// Clears the value of `images`. Subsequent reads from it will return its default value.
  public mutating func clearImages() {_uniqueStorage()._images = nil}

  public var displayDescription: String {
    get {return _storage._displayDescription}
    set {_uniqueStorage()._displayDescription = newValue}
  }

  public var capabilities: [Provider.Capability] {
    get {return _storage._capabilities}
    set {_uniqueStorage()._capabilities = newValue}
  }

  public var marketCode: String {
    get {return _storage._marketCode}
    set {_uniqueStorage()._marketCode = newValue}
  }

  public var accessType: Provider.AccessType {
    get {return _storage._accessType}
    set {_uniqueStorage()._accessType = newValue}
  }

  /// ASS-247: 15 and 16 is removed in favor of 17 and 18
  public var financialInstitutionID: String {
    get {return _storage._financialInstitutionID}
    set {_uniqueStorage()._financialInstitutionID = newValue}
  }

  public var financialInstitutionName: String {
    get {return _storage._financialInstitutionName}
    set {_uniqueStorage()._financialInstitutionName = newValue}
  }

  public var authenticationFlow: Provider.AuthenticationFlow {
    get {return _storage._authenticationFlow}
    set {_uniqueStorage()._authenticationFlow = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case bank // = 1
    case creditCard // = 2
    case broker // = 3
    case other // = 4
    case test // = 5
    case fraud // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .bank
      case 2: self = .creditCard
      case 3: self = .broker
      case 4: self = .other
      case 5: self = .test
      case 6: self = .fraud
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .bank: return 1
      case .creditCard: return 2
      case .broker: return 3
      case .other: return 4
      case .test: return 5
      case .fraud: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case enabled // = 1
    case disabled // = 2
    case temporaryDisabled // = 3
    case obsolete // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .enabled
      case 2: self = .disabled
      case 3: self = .temporaryDisabled
      case 4: self = .obsolete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .enabled: return 1
      case .disabled: return 2
      case .temporaryDisabled: return 3
      case .obsolete: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Capability: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case transfers // = 1
    case mortgageAggregation // = 2
    case checkingAccounts // = 3
    case savingsAccounts // = 4
    case creditCards // = 5
    case investments // = 6
    case loans // = 7
    case payments // = 8
    case mortgageLoan // = 9
    case identityData // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .transfers
      case 2: self = .mortgageAggregation
      case 3: self = .checkingAccounts
      case 4: self = .savingsAccounts
      case 5: self = .creditCards
      case 6: self = .investments
      case 7: self = .loans
      case 8: self = .payments
      case 9: self = .mortgageLoan
      case 10: self = .identityData
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .transfers: return 1
      case .mortgageAggregation: return 2
      case .checkingAccounts: return 3
      case .savingsAccounts: return 4
      case .creditCards: return 5
      case .investments: return 6
      case .loans: return 7
      case .payments: return 8
      case .mortgageLoan: return 9
      case .identityData: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum AccessType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case openBanking // = 1
    case other // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .openBanking
      case 2: self = .other
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .openBanking: return 1
      case .other: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum AuthenticationFlow: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case embedded // = 1
    case redirect // = 2
    case decoupled // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .embedded
      case 2: self = .redirect
      case 3: self = .decoupled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .embedded: return 1
      case .redirect: return 2
      case .decoupled: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Provider.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Provider.TypeEnum] = [
    .unknown,
    .bank,
    .creditCard,
    .broker,
    .other,
    .test,
    .fraud,
  ]
}

extension Provider.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Provider.Status] = [
    .unknown,
    .enabled,
    .disabled,
    .temporaryDisabled,
    .obsolete,
  ]
}

extension Provider.Capability: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Provider.Capability] = [
    .unknown,
    .transfers,
    .mortgageAggregation,
    .checkingAccounts,
    .savingsAccounts,
    .creditCards,
    .investments,
    .loans,
    .payments,
    .mortgageLoan,
    .identityData,
  ]
}

extension Provider.AccessType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Provider.AccessType] = [
    .unknown,
    .openBanking,
    .other,
  ]
}

extension Provider.AuthenticationFlow: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Provider.AuthenticationFlow] = [
    .unknown,
    .embedded,
    .redirect,
    .decoupled,
  ]
}

#endif  // swift(>=4.2)

public struct CurrencyDenominatedAmount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: ExactNumber {
    get {return _storage._value ?? ExactNumber()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var currencyCode: String {
    get {return _storage._currencyCode}
    set {_uniqueStorage()._currencyCode = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ExactNumber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unscaledValue: Int64 = 0

  public var scale: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Period {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var year: UInt32 {
    get {return _storage._year}
    set {_uniqueStorage()._year = newValue}
  }

  public var month: UInt32 {
    get {return _storage._month}
    set {_uniqueStorage()._month = newValue}
  }

  public var week: UInt32 {
    get {return _storage._week}
    set {_uniqueStorage()._week = newValue}
  }

  public var day: UInt32 {
    get {return _storage._day}
    set {_uniqueStorage()._day = newValue}
  }

  public var start: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return _storage._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {_uniqueStorage()._start = nil}

  public var stop: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._stop ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._stop = newValue}
  }
  /// Returns true if `stop` has been explicitly set.
  public var hasStop: Bool {return _storage._stop != nil}
  /// Clears the value of `stop`. Subsequent reads from it will return its default value.
  public mutating func clearStop() {_uniqueStorage()._stop = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct PeriodDescription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var year: UInt32 = 0

  public var month: UInt32 = 0

  public var week: UInt32 = 0

  public var day: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct StatisticTree {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var balancesByAccountID: Dictionary<String,StatisticNode> = [:]

  public var balancesByAccountGroupType: Dictionary<String,StatisticNode> = [:]

  public var leftToSpend: Dictionary<String,StatisticNode> = [:]

  public var expensesByCategoryCode: Dictionary<String,StatisticNode> = [:]

  public var incomeByCategoryCode: Dictionary<String,StatisticNode> = [:]

  public var loanRatesByProperty: Dictionary<String,StatisticNode> = [:]

  public var loanBalancesByProperty: Dictionary<String,StatisticNode> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case balancesByAccountID // = 1
    case balancesByAccountGroupType // = 2
    case leftToSpend // = 3
    case expencesByCategoryCode // = 4
    case incomeByCategoryCode // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .balancesByAccountID
      case 2: self = .balancesByAccountGroupType
      case 3: self = .leftToSpend
      case 4: self = .expencesByCategoryCode
      case 5: self = .incomeByCategoryCode
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .balancesByAccountID: return 1
      case .balancesByAccountGroupType: return 2
      case .leftToSpend: return 3
      case .expencesByCategoryCode: return 4
      case .incomeByCategoryCode: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension StatisticTree.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [StatisticTree.TypeEnum] = [
    .unknown,
    .balancesByAccountID,
    .balancesByAccountGroupType,
    .leftToSpend,
    .expencesByCategoryCode,
    .incomeByCategoryCode,
  ]
}

#endif  // swift(>=4.2)

public struct StatisticNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var period: Period {
    get {return _storage._period ?? Period()}
    set {_uniqueStorage()._period = newValue}
  }
  /// Returns true if `period` has been explicitly set.
  public var hasPeriod: Bool {return _storage._period != nil}
  /// Clears the value of `period`. Subsequent reads from it will return its default value.
  public mutating func clearPeriod() {_uniqueStorage()._period = nil}

  public var nodeValue: OneOf_NodeValue? {
    get {return _storage._nodeValue}
    set {_uniqueStorage()._nodeValue = newValue}
  }

  /// Used if the value on the node is related to a currency, like "balances by account"
  public var amount: CurrencyDenominatedAmount {
    get {
      if case .amount(let v)? = _storage._nodeValue {return v}
      return CurrencyDenominatedAmount()
    }
    set {_uniqueStorage()._nodeValue = .amount(newValue)}
  }

  /// Used if the value on the node isn't related to a currency, like "loan rate by property"
  public var value: ExactNumber {
    get {
      if case .value(let v)? = _storage._nodeValue {return v}
      return ExactNumber()
    }
    set {_uniqueStorage()._nodeValue = .value(newValue)}
  }

  public var children: Dictionary<String,StatisticNode> {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_NodeValue: Equatable {
    /// Used if the value on the node is related to a currency, like "balances by account"
    case amount(CurrencyDenominatedAmount)
    /// Used if the value on the node isn't related to a currency, like "loan rate by property"
    case value(ExactNumber)

  #if !swift(>=4.1)
    public static func ==(lhs: StatisticNode.OneOf_NodeValue, rhs: StatisticNode.OneOf_NodeValue) -> Bool {
      switch (lhs, rhs) {
      case (.amount(let l), .amount(let r)): return l == r
      case (.value(let l), .value(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct FollowItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var criteria: OneOf_Criteria? {
    get {return _storage._criteria}
    set {_uniqueStorage()._criteria = newValue}
  }

  public var expensesCriteria: ExpensesFollowCriteria {
    get {
      if case .expensesCriteria(let v)? = _storage._criteria {return v}
      return ExpensesFollowCriteria()
    }
    set {_uniqueStorage()._criteria = .expensesCriteria(newValue)}
  }

  public var searchCriteria: SearchFollowCriteria {
    get {
      if case .searchCriteria(let v)? = _storage._criteria {return v}
      return SearchFollowCriteria()
    }
    set {_uniqueStorage()._criteria = .searchCriteria(newValue)}
  }

  public var savingCriteria: SavingsFollowCriteria {
    get {
      if case .savingCriteria(let v)? = _storage._criteria {return v}
      return SavingsFollowCriteria()
    }
    set {_uniqueStorage()._criteria = .savingCriteria(newValue)}
  }

  public var data: FollowData {
    get {return _storage._data ?? FollowData()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var createdDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdDate = newValue}
  }
  /// Returns true if `createdDate` has been explicitly set.
  public var hasCreatedDate: Bool {return _storage._createdDate != nil}
  /// Clears the value of `createdDate`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedDate() {_uniqueStorage()._createdDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Criteria: Equatable {
    case expensesCriteria(ExpensesFollowCriteria)
    case searchCriteria(SearchFollowCriteria)
    case savingCriteria(SavingsFollowCriteria)

  #if !swift(>=4.1)
    public static func ==(lhs: FollowItem.OneOf_Criteria, rhs: FollowItem.OneOf_Criteria) -> Bool {
      switch (lhs, rhs) {
      case (.expensesCriteria(let l), .expensesCriteria(let r)): return l == r
      case (.searchCriteria(let l), .searchCriteria(let r)): return l == r
      case (.savingCriteria(let l), .savingCriteria(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct FollowItemHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var historicalAmounts: [PeriodExactNumberPair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ExpensesFollowCriteria {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetAmount: ExactNumber {
    get {return _storage._targetAmount ?? ExactNumber()}
    set {_uniqueStorage()._targetAmount = newValue}
  }
  /// Returns true if `targetAmount` has been explicitly set.
  public var hasTargetAmount: Bool {return _storage._targetAmount != nil}
  /// Clears the value of `targetAmount`. Subsequent reads from it will return its default value.
  public mutating func clearTargetAmount() {_uniqueStorage()._targetAmount = nil}

  public var categoryCodes: [String] {
    get {return _storage._categoryCodes}
    set {_uniqueStorage()._categoryCodes = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct SearchFollowCriteria {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetAmount: ExactNumber {
    get {return _storage._targetAmount ?? ExactNumber()}
    set {_uniqueStorage()._targetAmount = newValue}
  }
  /// Returns true if `targetAmount` has been explicitly set.
  public var hasTargetAmount: Bool {return _storage._targetAmount != nil}
  /// Clears the value of `targetAmount`. Subsequent reads from it will return its default value.
  public mutating func clearTargetAmount() {_uniqueStorage()._targetAmount = nil}

  public var query: String {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct SavingsFollowCriteria {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetAmount: ExactNumber {
    get {return _storage._targetAmount ?? ExactNumber()}
    set {_uniqueStorage()._targetAmount = newValue}
  }
  /// Returns true if `targetAmount` has been explicitly set.
  public var hasTargetAmount: Bool {return _storage._targetAmount != nil}
  /// Clears the value of `targetAmount`. Subsequent reads from it will return its default value.
  public mutating func clearTargetAmount() {_uniqueStorage()._targetAmount = nil}

  public var accountIds: [String] {
    get {return _storage._accountIds}
    set {_uniqueStorage()._accountIds = newValue}
  }

  public var period: String {
    get {return _storage._period}
    set {_uniqueStorage()._period = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct FollowData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var historicalAmounts: [PeriodExactNumberPair] {
    get {return _storage._historicalAmounts}
    set {_uniqueStorage()._historicalAmounts = newValue}
  }

  public var period: Period {
    get {return _storage._period ?? Period()}
    set {_uniqueStorage()._period = newValue}
  }
  /// Returns true if `period` has been explicitly set.
  public var hasPeriod: Bool {return _storage._period != nil}
  /// Clears the value of `period`. Subsequent reads from it will return its default value.
  public mutating func clearPeriod() {_uniqueStorage()._period = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct PeriodExactNumberPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var period: Period {
    get {return _storage._period ?? Period()}
    set {_uniqueStorage()._period = newValue}
  }
  /// Returns true if `period` has been explicitly set.
  public var hasPeriod: Bool {return _storage._period != nil}
  /// Clears the value of `period`. Subsequent reads from it will return its default value.
  public mutating func clearPeriod() {_uniqueStorage()._period = nil}

  public var value: ExactNumber {
    get {return _storage._value ?? ExactNumber()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Budget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Specification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    public var name: String {
      get {return _storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    public var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    public var amount: CurrencyDenominatedAmount {
      get {return _storage._amount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    public var hasAmount: Bool {return _storage._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    public mutating func clearAmount() {_uniqueStorage()._amount = nil}

    public var periodicity: OneOf_Periodicity? {
      get {return _storage._periodicity}
      set {_uniqueStorage()._periodicity = newValue}
    }

    public var recurringPeriodicity: Budget.RecurringPeriodicity {
      get {
        if case .recurringPeriodicity(let v)? = _storage._periodicity {return v}
        return Budget.RecurringPeriodicity()
      }
      set {_uniqueStorage()._periodicity = .recurringPeriodicity(newValue)}
    }

    public var oneOffPeriodicity: Budget.OneOffPeriodicity {
      get {
        if case .oneOffPeriodicity(let v)? = _storage._periodicity {return v}
        return Budget.OneOffPeriodicity()
      }
      set {_uniqueStorage()._periodicity = .oneOffPeriodicity(newValue)}
    }

    public var archived: Bool {
      get {return _storage._archived}
      set {_uniqueStorage()._archived = newValue}
    }

    public var filter: Budget.Filter {
      get {return _storage._filter ?? Budget.Filter()}
      set {_uniqueStorage()._filter = newValue}
    }
    /// Returns true if `filter` has been explicitly set.
    public var hasFilter: Bool {return _storage._filter != nil}
    /// Clears the value of `filter`. Subsequent reads from it will return its default value.
    public mutating func clearFilter() {_uniqueStorage()._filter = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Periodicity: Equatable {
      case recurringPeriodicity(Budget.RecurringPeriodicity)
      case oneOffPeriodicity(Budget.OneOffPeriodicity)

    #if !swift(>=4.1)
      public static func ==(lhs: Budget.Specification.OneOf_Periodicity, rhs: Budget.Specification.OneOf_Periodicity) -> Bool {
        switch (lhs, rhs) {
        case (.recurringPeriodicity(let l), .recurringPeriodicity(let r)): return l == r
        case (.oneOffPeriodicity(let l), .oneOffPeriodicity(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Filter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var accounts: [Budget.Filter.Account] = []

    public var categories: [Budget.Filter.Category] = []

    public var tags: [Budget.Filter.Tag] = []

    public var freeTextQuery: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Account {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Category {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var code: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Tag {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var key: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct OneOffPeriodicity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var start: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    public var hasStart: Bool {return _storage._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    public mutating func clearStart() {_uniqueStorage()._start = nil}

    public var end: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    public var hasEnd: Bool {return _storage._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    public mutating func clearEnd() {_uniqueStorage()._end = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct RecurringPeriodicity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var periodUnit: Budget.RecurringPeriodicity.PeriodUnit = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum PeriodUnit: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0
      case week // = 1
      case month // = 2
      case year // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .week
        case 2: self = .month
        case 3: self = .year
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .week: return 1
        case .month: return 2
        case .year: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct Period {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var start: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    public var hasStart: Bool {return _storage._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    public mutating func clearStart() {_uniqueStorage()._start = nil}

    public var end: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    public var hasEnd: Bool {return _storage._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    public mutating func clearEnd() {_uniqueStorage()._end = nil}

    public var spentAmount: CurrencyDenominatedAmount {
      get {return _storage._spentAmount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._spentAmount = newValue}
    }
    /// Returns true if `spentAmount` has been explicitly set.
    public var hasSpentAmount: Bool {return _storage._spentAmount != nil}
    /// Clears the value of `spentAmount`. Subsequent reads from it will return its default value.
    public mutating func clearSpentAmount() {_uniqueStorage()._spentAmount = nil}

    public var budgetAmount: CurrencyDenominatedAmount {
      get {return _storage._budgetAmount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._budgetAmount = newValue}
    }
    /// Returns true if `budgetAmount` has been explicitly set.
    public var hasBudgetAmount: Bool {return _storage._budgetAmount != nil}
    /// Clears the value of `budgetAmount`. Subsequent reads from it will return its default value.
    public mutating func clearBudgetAmount() {_uniqueStorage()._budgetAmount = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Summary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var budgetSpecification: Budget.Specification {
      get {return _storage._budgetSpecification ?? Budget.Specification()}
      set {_uniqueStorage()._budgetSpecification = newValue}
    }
    /// Returns true if `budgetSpecification` has been explicitly set.
    public var hasBudgetSpecification: Bool {return _storage._budgetSpecification != nil}
    /// Clears the value of `budgetSpecification`. Subsequent reads from it will return its default value.
    public mutating func clearBudgetSpecification() {_uniqueStorage()._budgetSpecification = nil}

    public var currentBudgetPeriod: Budget.Period {
      get {return _storage._currentBudgetPeriod ?? Budget.Period()}
      set {_uniqueStorage()._currentBudgetPeriod = newValue}
    }
    /// Returns true if `currentBudgetPeriod` has been explicitly set.
    public var hasCurrentBudgetPeriod: Bool {return _storage._currentBudgetPeriod != nil}
    /// Clears the value of `currentBudgetPeriod`. Subsequent reads from it will return its default value.
    public mutating func clearCurrentBudgetPeriod() {_uniqueStorage()._currentBudgetPeriod = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Transaction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    public var amount: CurrencyDenominatedAmount {
      get {return _storage._amount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    public var hasAmount: Bool {return _storage._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    public mutating func clearAmount() {_uniqueStorage()._amount = nil}

    public var dispensableAmount: CurrencyDenominatedAmount {
      get {return _storage._dispensableAmount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._dispensableAmount = newValue}
    }
    /// Returns true if `dispensableAmount` has been explicitly set.
    public var hasDispensableAmount: Bool {return _storage._dispensableAmount != nil}
    /// Clears the value of `dispensableAmount`. Subsequent reads from it will return its default value.
    public mutating func clearDispensableAmount() {_uniqueStorage()._dispensableAmount = nil}

    public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    public var hasDate: Bool {return _storage._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    public mutating func clearDate() {_uniqueStorage()._date = nil}

    public var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    public var categoryCode: String {
      get {return _storage._categoryCode}
      set {_uniqueStorage()._categoryCode = newValue}
    }

    public var accountID: String {
      get {return _storage._accountID}
      set {_uniqueStorage()._accountID = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

public struct Currency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var factor: ExactNumber {
    get {return _storage._factor ?? ExactNumber()}
    set {_uniqueStorage()._factor = newValue}
  }
  /// Returns true if `factor` has been explicitly set.
  public var hasFactor: Bool {return _storage._factor != nil}
  /// Clears the value of `factor`. Subsequent reads from it will return its default value.
  public mutating func clearFactor() {_uniqueStorage()._factor = nil}

  public var prefixed: Bool {
    get {return _storage._prefixed}
    set {_uniqueStorage()._prefixed = newValue}
  }

  public var symbol: String {
    get {return _storage._symbol}
    set {_uniqueStorage()._symbol = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Loan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  public var interest: ExactNumber {
    get {return _storage._interest ?? ExactNumber()}
    set {_uniqueStorage()._interest = newValue}
  }
  /// Returns true if `interest` has been explicitly set.
  public var hasInterest: Bool {return _storage._interest != nil}
  /// Clears the value of `interest`. Subsequent reads from it will return its default value.
  public mutating func clearInterest() {_uniqueStorage()._interest = nil}

  public var numberOfMonthsBound: Int32 {
    get {return _storage._numberOfMonthsBound}
    set {_uniqueStorage()._numberOfMonthsBound = newValue}
  }

  public var type: Loan.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case mortgage // = 1
    case blanco // = 2
    case membership // = 3
    case vehicle // = 4
    case land // = 5
    case student // = 6
    case other // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .mortgage
      case 2: self = .blanco
      case 3: self = .membership
      case 4: self = .vehicle
      case 5: self = .land
      case 6: self = .student
      case 7: self = .other
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .mortgage: return 1
      case .blanco: return 2
      case .membership: return 3
      case .vehicle: return 4
      case .land: return 5
      case .student: return 6
      case .other: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Loan.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Loan.TypeEnum] = [
    .unknown,
    .mortgage,
    .blanco,
    .membership,
    .vehicle,
    .land,
    .student,
    .other,
  ]
}

#endif  // swift(>=4.2)

public struct CategoryTree {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expenses: CategoryNode {
    get {return _storage._expenses ?? CategoryNode()}
    set {_uniqueStorage()._expenses = newValue}
  }
  /// Returns true if `expenses` has been explicitly set.
  public var hasExpenses: Bool {return _storage._expenses != nil}
  /// Clears the value of `expenses`. Subsequent reads from it will return its default value.
  public mutating func clearExpenses() {_uniqueStorage()._expenses = nil}

  public var income: CategoryNode {
    get {return _storage._income ?? CategoryNode()}
    set {_uniqueStorage()._income = newValue}
  }
  /// Returns true if `income` has been explicitly set.
  public var hasIncome: Bool {return _storage._income != nil}
  /// Clears the value of `income`. Subsequent reads from it will return its default value.
  public mutating func clearIncome() {_uniqueStorage()._income = nil}

  public var transfers: CategoryNode {
    get {return _storage._transfers ?? CategoryNode()}
    set {_uniqueStorage()._transfers = newValue}
  }
  /// Returns true if `transfers` has been explicitly set.
  public var hasTransfers: Bool {return _storage._transfers != nil}
  /// Clears the value of `transfers`. Subsequent reads from it will return its default value.
  public mutating func clearTransfers() {_uniqueStorage()._transfers = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct CategoryNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var id: String = String()

  public var name: String = String()

  public var children: [CategoryNode] = []

  public var sortOrder: Int32 = 0

  public var defaultChild: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var notificationToken: String = String()

  public var notificationPublicKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DeviceAppsFlyerOrigin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var extraParam1: String = String()

  public var extraParam2: String = String()

  public var extraParam3: String = String()

  public var extraParam4: String = String()

  public var extraParam5: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DeviceFacebookOrigin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var campaignID: String = String()

  public var adGroupID: String = String()

  public var adGroupName: String = String()

  public var adSetID: String = String()

  public var adSetName: String = String()

  public var adID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProviderFieldSpecification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var description_p: String = String()

  public var hint: String = String()

  public var maxLength: Int32 = 0

  public var minLength: Int32 = 0

  public var masked: Bool = false

  public var numeric: Bool = false

  public var immutable: Bool = false

  public var optional: Bool = false

  public var name: String = String()

  public var value: String = String()

  public var pattern: String = String()

  public var patternError: String = String()

  public var helpText: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GiroLookupEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  public var identifier: String {
    get {return _storage._identifier}
    set {_uniqueStorage()._identifier = newValue}
  }

  public var images: Images {
    get {return _storage._images ?? Images()}
    set {_uniqueStorage()._images = newValue}
  }
  /// Returns true if `images` has been explicitly set.
  public var hasImages: Bool {return _storage._images != nil}
  /// Clears the value of `images`. Subsequent reads from it will return its default value.
  public mutating func clearImages() {_uniqueStorage()._images = nil}

  public var displayNumber: String {
    get {return _storage._displayNumber}
    set {_uniqueStorage()._displayNumber = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Images {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var iconURL: String = String()

  public var bannerURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SignableOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_uniqueStorage()._created = nil}

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var status: SignableOperation.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var statusMessage: String {
    get {return _storage._statusMessage}
    set {_uniqueStorage()._statusMessage = newValue}
  }

  public var type: SignableOperation.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var underlyingID: String {
    get {return _storage._underlyingID}
    set {_uniqueStorage()._underlyingID = newValue}
  }

  public var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  public var hasUpdated: Bool {return _storage._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  public mutating func clearUpdated() {_uniqueStorage()._updated = nil}

  public var credentialID: String {
    get {return _storage._credentialID}
    set {_uniqueStorage()._credentialID = newValue}
  }

  public var thirdPartyAppAuthentication: ThirdPartyAppAuthentication {
    get {return _storage._thirdPartyAppAuthentication ?? ThirdPartyAppAuthentication()}
    set {_uniqueStorage()._thirdPartyAppAuthentication = newValue}
  }
  /// Returns true if `thirdPartyAppAuthentication` has been explicitly set.
  public var hasThirdPartyAppAuthentication: Bool {return _storage._thirdPartyAppAuthentication != nil}
  /// Clears the value of `thirdPartyAppAuthentication`. Subsequent reads from it will return its default value.
  public mutating func clearThirdPartyAppAuthentication() {_uniqueStorage()._thirdPartyAppAuthentication = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case created // = 1
    case executing // = 2
    case awaitingCredentials // = 3
    case cancelled // = 4
    case failed // = 5
    case executed // = 6
    case awaitingThirdPartyAppAuthentication // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .created
      case 2: self = .executing
      case 3: self = .awaitingCredentials
      case 4: self = .cancelled
      case 5: self = .failed
      case 6: self = .executed
      case 7: self = .awaitingThirdPartyAppAuthentication
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .created: return 1
      case .executing: return 2
      case .awaitingCredentials: return 3
      case .cancelled: return 4
      case .failed: return 5
      case .executed: return 6
      case .awaitingThirdPartyAppAuthentication: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case transfer // = 1
    case accountCreate // = 2
    case application // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .transfer
      case 2: self = .accountCreate
      case 3: self = .application
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .transfer: return 1
      case .accountCreate: return 2
      case .application: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension SignableOperation.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SignableOperation.Status] = [
    .unknown,
    .created,
    .executing,
    .awaitingCredentials,
    .cancelled,
    .failed,
    .executed,
    .awaitingThirdPartyAppAuthentication,
  ]
}

extension SignableOperation.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SignableOperation.TypeEnum] = [
    .unknown,
    .transfer,
    .accountCreate,
    .application,
  ]
}

#endif  // swift(>=4.2)

public struct TrackingEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var category: String {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  public var action: String {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var label: String {
    get {return _storage._label}
    set {_uniqueStorage()._label = newValue}
  }

  public var defaultValue: Int64 {
    get {return _storage._defaultValue}
    set {_uniqueStorage()._defaultValue = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TrackingTiming {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var category: String {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  public var label: String {
    get {return _storage._label}
    set {_uniqueStorage()._label = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TrackingView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TransactionCluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var transactions: [Transaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  public var score: ExactNumber {
    get {return _storage._score ?? ExactNumber()}
    set {_uniqueStorage()._score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return _storage._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {_uniqueStorage()._score = nil}

  public var categorizationImprovement: ExactNumber {
    get {return _storage._categorizationImprovement ?? ExactNumber()}
    set {_uniqueStorage()._categorizationImprovement = newValue}
  }
  /// Returns true if `categorizationImprovement` has been explicitly set.
  public var hasCategorizationImprovement: Bool {return _storage._categorizationImprovement != nil}
  /// Clears the value of `categorizationImprovement`. Subsequent reads from it will return its default value.
  public mutating func clearCategorizationImprovement() {_uniqueStorage()._categorizationImprovement = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TransferDestination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uri: String {
    get {return _storage._uri}
    set {_uniqueStorage()._uri = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var balance: CurrencyDenominatedAmount {
    get {return _storage._balance ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var displayBankName: String {
    get {return _storage._displayBankName}
    set {_uniqueStorage()._displayBankName = newValue}
  }

  public var type: Account.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var images: Images {
    get {return _storage._images ?? Images()}
    set {_uniqueStorage()._images = newValue}
  }
  /// Returns true if `images` has been explicitly set.
  public var hasImages: Bool {return _storage._images != nil}
  /// Clears the value of `images`. Subsequent reads from it will return its default value.
  public mutating func clearImages() {_uniqueStorage()._images = nil}

  public var displayAccountNumber: String {
    get {return _storage._displayAccountNumber}
    set {_uniqueStorage()._displayAccountNumber = newValue}
  }

  public var matchesMultiple: Bool {
    get {return _storage._matchesMultiple}
    set {_uniqueStorage()._matchesMultiple = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TransferDestinationPerAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountID: String = String()

  public var destinations: [TransferDestination] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Transfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: CurrencyDenominatedAmount {
    get {return _storage._amount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var credentialID: String {
    get {return _storage._credentialID}
    set {_uniqueStorage()._credentialID = newValue}
  }

  public var destinationUri: String {
    get {return _storage._destinationUri}
    set {_uniqueStorage()._destinationUri = newValue}
  }

  public var destinationMessage: String {
    get {return _storage._destinationMessage}
    set {_uniqueStorage()._destinationMessage = newValue}
  }

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var sourceUri: String {
    get {return _storage._sourceUri}
    set {_uniqueStorage()._sourceUri = newValue}
  }

  public var sourceMessage: String {
    get {return _storage._sourceMessage}
    set {_uniqueStorage()._sourceMessage = newValue}
  }

  public var type: Transfer.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var dueDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dueDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dueDate = newValue}
  }
  /// Returns true if `dueDate` has been explicitly set.
  public var hasDueDate: Bool {return _storage._dueDate != nil}
  /// Clears the value of `dueDate`. Subsequent reads from it will return its default value.
  public mutating func clearDueDate() {_uniqueStorage()._dueDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case einvoice // = 1
    case payment // = 2
    case bankTransfer // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .einvoice
      case 2: self = .payment
      case 3: self = .bankTransfer
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .einvoice: return 1
      case .payment: return 2
      case .bankTransfer: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Transfer.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Transfer.TypeEnum] = [
    .unknown,
    .einvoice,
    .payment,
    .bankTransfer,
  ]
}

#endif  // swift(>=4.2)

public struct UserProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  public var nationalID: String {
    get {return _storage._nationalID}
    set {_uniqueStorage()._nationalID = newValue}
  }

  /// The login methods that the user is authorized to use, for example `BANKID`.
  public var authorizedLoginMethods: [AuthenticationMethod] {
    get {return _storage._authorizedLoginMethods}
    set {_uniqueStorage()._authorizedLoginMethods = newValue}
  }

  /// The login methods that are available on the market, for example `EMAIL_AND_PASSWORD` and `BANKID`.
  public var availableLoginMethods: [AuthenticationMethod] {
    get {return _storage._availableLoginMethods}
    set {_uniqueStorage()._availableLoginMethods = newValue}
  }

  public var createdDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdDate = newValue}
  }
  /// Returns true if `createdDate` has been explicitly set.
  public var hasCreatedDate: Bool {return _storage._createdDate != nil}
  /// Clears the value of `createdDate`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedDate() {_uniqueStorage()._createdDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct UserConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var flags: [String] {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  public var i18NConfiguration: UserConfiguration.I18NConfiguration {
    get {return _storage._i18NConfiguration ?? UserConfiguration.I18NConfiguration()}
    set {_uniqueStorage()._i18NConfiguration = newValue}
  }
  /// Returns true if `i18NConfiguration` has been explicitly set.
  public var hasI18NConfiguration: Bool {return _storage._i18NConfiguration != nil}
  /// Clears the value of `i18NConfiguration`. Subsequent reads from it will return its default value.
  public mutating func clearI18NConfiguration() {_uniqueStorage()._i18NConfiguration = nil}

  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct I18NConfiguration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var currencyCode: String = String()

    public var localeCode: String = String()

    public var marketCode: String = String()

    public var timezoneCode: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct I18NSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var localeCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PeriodSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var periodDateBreakType: PeriodDateBreakType = .unknown

  public var monthlyAdjustedDay: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct NotificationSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groups: [NotificationGroup] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct NotificationGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var notificationTypes: [NotificationType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct NotificationType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var title: String = String()

  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserOrigin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var serviceName: String {
    get {return _storage._serviceName}
    set {_uniqueStorage()._serviceName = newValue}
  }

  public var organic: Bool {
    get {return _storage._organic}
    set {_uniqueStorage()._organic = newValue}
  }

  public var externalServiceID: String {
    get {return _storage._externalServiceID}
    set {_uniqueStorage()._externalServiceID = newValue}
  }

  public var mediaSource: String {
    get {return _storage._mediaSource}
    set {_uniqueStorage()._mediaSource = newValue}
  }

  public var campaign: String {
    get {return _storage._campaign}
    set {_uniqueStorage()._campaign = newValue}
  }

  public var agency: String {
    get {return _storage._agency}
    set {_uniqueStorage()._agency = newValue}
  }

  public var clickTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._clickTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._clickTime = newValue}
  }
  /// Returns true if `clickTime` has been explicitly set.
  public var hasClickTime: Bool {return _storage._clickTime != nil}
  /// Clears the value of `clickTime`. Subsequent reads from it will return its default value.
  public mutating func clearClickTime() {_uniqueStorage()._clickTime = nil}

  public var installTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._installTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._installTime = newValue}
  }
  /// Returns true if `installTime` has been explicitly set.
  public var hasInstallTime: Bool {return _storage._installTime != nil}
  /// Clears the value of `installTime`. Subsequent reads from it will return its default value.
  public mutating func clearInstallTime() {_uniqueStorage()._installTime = nil}

  public var extraParam1: String {
    get {return _storage._extraParam1}
    set {_uniqueStorage()._extraParam1 = newValue}
  }

  public var extraParam2: String {
    get {return _storage._extraParam2}
    set {_uniqueStorage()._extraParam2 = newValue}
  }

  public var extraParam3: String {
    get {return _storage._extraParam3}
    set {_uniqueStorage()._extraParam3 = newValue}
  }

  public var extraParam4: String {
    get {return _storage._extraParam4}
    set {_uniqueStorage()._extraParam4 = newValue}
  }

  public var extraParam5: String {
    get {return _storage._extraParam5}
    set {_uniqueStorage()._extraParam5 = newValue}
  }

  public var facebookAd: FacebookAd {
    get {return _storage._facebookAd ?? FacebookAd()}
    set {_uniqueStorage()._facebookAd = newValue}
  }
  /// Returns true if `facebookAd` has been explicitly set.
  public var hasFacebookAd: Bool {return _storage._facebookAd != nil}
  /// Clears the value of `facebookAd`. Subsequent reads from it will return its default value.
  public mutating func clearFacebookAd() {_uniqueStorage()._facebookAd = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct FacebookAd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: String = String()

  public var groupName: String = String()

  public var campaignID: String = String()

  public var adSetID: String = String()

  public var adSetName: String = String()

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AuthenticationKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyType: AuthenticationKeyType = .keyTypeUnknown

  public var id: String = String()

  public var key: String = String()

  public var source: AuthenticationSource = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IdentityEventAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var label: String = String()

  public var key: IdentityAnswerKey = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IdentityEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var seen: Bool {
    get {return _storage._seen}
    set {_uniqueStorage()._seen = newValue}
  }

  public var question: String {
    get {return _storage._question}
    set {_uniqueStorage()._question = newValue}
  }

  public var potentialAnswers: [IdentityEventAnswer] {
    get {return _storage._potentialAnswers}
    set {_uniqueStorage()._potentialAnswers = newValue}
  }

  public var answer: IdentityDocumentedAnswer {
    get {return _storage._answer ?? IdentityDocumentedAnswer()}
    set {_uniqueStorage()._answer = newValue}
  }
  /// Returns true if `answer` has been explicitly set.
  public var hasAnswer: Bool {return _storage._answer != nil}
  /// Clears the value of `answer`. Subsequent reads from it will return its default value.
  public mutating func clearAnswer() {_uniqueStorage()._answer = nil}

  public var documentation: IdentityEventDocumentation {
    get {return _storage._documentation ?? IdentityEventDocumentation()}
    set {_uniqueStorage()._documentation = newValue}
  }
  /// Returns true if `documentation` has been explicitly set.
  public var hasDocumentation: Bool {return _storage._documentation != nil}
  /// Clears the value of `documentation`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentation() {_uniqueStorage()._documentation = nil}

  public var transactions: [Transaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IdentityEventSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var seen: Bool {
    get {return _storage._seen}
    set {_uniqueStorage()._seen = newValue}
  }

  public var answer: IdentityDocumentedAnswer {
    get {return _storage._answer ?? IdentityDocumentedAnswer()}
    set {_uniqueStorage()._answer = newValue}
  }
  /// Returns true if `answer` has been explicitly set.
  public var hasAnswer: Bool {return _storage._answer != nil}
  /// Clears the value of `answer`. Subsequent reads from it will return its default value.
  public mutating func clearAnswer() {_uniqueStorage()._answer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IdentityEventDocumentation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var source: String = String()

  public var infoTitle: String = String()

  public var infoBody: String = String()

  public var helpTitle: String = String()

  public var helpBody: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IdentityStateAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var postalCode: String = String()

  public var city: String = String()

  public var community: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IdentityStateProperty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var municipality: String {
    get {return _storage._municipality}
    set {_uniqueStorage()._municipality = newValue}
  }

  public var number: String {
    get {return _storage._number}
    set {_uniqueStorage()._number = newValue}
  }

  public var acquisitionDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._acquisitionDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._acquisitionDate = newValue}
  }
  /// Returns true if `acquisitionDate` has been explicitly set.
  public var hasAcquisitionDate: Bool {return _storage._acquisitionDate != nil}
  /// Clears the value of `acquisitionDate`. Subsequent reads from it will return its default value.
  public mutating func clearAcquisitionDate() {_uniqueStorage()._acquisitionDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IdentityStateCompany {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var number: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IdentityStateRole {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IdentityStateCompanyEngagement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var company: IdentityStateCompany {
    get {return _storage._company ?? IdentityStateCompany()}
    set {_uniqueStorage()._company = newValue}
  }
  /// Returns true if `company` has been explicitly set.
  public var hasCompany: Bool {return _storage._company != nil}
  /// Clears the value of `company`. Subsequent reads from it will return its default value.
  public mutating func clearCompany() {_uniqueStorage()._company = nil}

  public var roles: [IdentityStateRole] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  public var dateIn: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._dateIn ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._dateIn = newValue}
  }
  /// Returns true if `dateIn` has been explicitly set.
  public var hasDateIn: Bool {return _storage._dateIn != nil}
  /// Clears the value of `dateIn`. Subsequent reads from it will return its default value.
  public mutating func clearDateIn() {_uniqueStorage()._dateIn = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IdentityStateCreditScore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var score: Int32 = 0

  public var maxScore: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IdentityStateTaxDeclaration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var finalTax: CurrencyDenominatedAmount {
    get {return _storage._finalTax ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._finalTax = newValue}
  }
  /// Returns true if `finalTax` has been explicitly set.
  public var hasFinalTax: Bool {return _storage._finalTax != nil}
  /// Clears the value of `finalTax`. Subsequent reads from it will return its default value.
  public mutating func clearFinalTax() {_uniqueStorage()._finalTax = nil}

  public var totalIncome: CurrencyDenominatedAmount {
    get {return _storage._totalIncome ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._totalIncome = newValue}
  }
  /// Returns true if `totalIncome` has been explicitly set.
  public var hasTotalIncome: Bool {return _storage._totalIncome != nil}
  /// Clears the value of `totalIncome`. Subsequent reads from it will return its default value.
  public mutating func clearTotalIncome() {_uniqueStorage()._totalIncome = nil}

  public var incomeByService: CurrencyDenominatedAmount {
    get {return _storage._incomeByService ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._incomeByService = newValue}
  }
  /// Returns true if `incomeByService` has been explicitly set.
  public var hasIncomeByService: Bool {return _storage._incomeByService != nil}
  /// Clears the value of `incomeByService`. Subsequent reads from it will return its default value.
  public mutating func clearIncomeByService() {_uniqueStorage()._incomeByService = nil}

  public var incomeByCapital: CurrencyDenominatedAmount {
    get {return _storage._incomeByCapital ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._incomeByCapital = newValue}
  }
  /// Returns true if `incomeByCapital` has been explicitly set.
  public var hasIncomeByCapital: Bool {return _storage._incomeByCapital != nil}
  /// Clears the value of `incomeByCapital`. Subsequent reads from it will return its default value.
  public mutating func clearIncomeByCapital() {_uniqueStorage()._incomeByCapital = nil}

  public var year: Int32 {
    get {return _storage._year}
    set {_uniqueStorage()._year = newValue}
  }

  public var registeredDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._registeredDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._registeredDate = newValue}
  }
  /// Returns true if `registeredDate` has been explicitly set.
  public var hasRegisteredDate: Bool {return _storage._registeredDate != nil}
  /// Clears the value of `registeredDate`. Subsequent reads from it will return its default value.
  public mutating func clearRegisteredDate() {_uniqueStorage()._registeredDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IdentityStateRecordOfNonPayment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var amount: CurrencyDenominatedAmount {
    get {return _storage._amount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var registeredDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._registeredDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._registeredDate = newValue}
  }
  /// Returns true if `registeredDate` has been explicitly set.
  public var hasRegisteredDate: Bool {return _storage._registeredDate != nil}
  /// Clears the value of `registeredDate`. Subsequent reads from it will return its default value.
  public mutating func clearRegisteredDate() {_uniqueStorage()._registeredDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IdentityStateOutstandingDebt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: CurrencyDenominatedAmount {
    get {return _storage._amount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var number: Int32 {
    get {return _storage._number}
    set {_uniqueStorage()._number = newValue}
  }

  public var registeredDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._registeredDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._registeredDate = newValue}
  }
  /// Returns true if `registeredDate` has been explicitly set.
  public var hasRegisteredDate: Bool {return _storage._registeredDate != nil}
  /// Clears the value of `registeredDate`. Subsequent reads from it will return its default value.
  public mutating func clearRegisteredDate() {_uniqueStorage()._registeredDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IdentityState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var firstName: String {
    get {return _storage._firstName}
    set {_uniqueStorage()._firstName = newValue}
  }

  public var lastName: String {
    get {return _storage._lastName}
    set {_uniqueStorage()._lastName = newValue}
  }

  public var nationalID: String {
    get {return _storage._nationalID}
    set {_uniqueStorage()._nationalID = newValue}
  }

  public var address: IdentityStateAddress {
    get {return _storage._address ?? IdentityStateAddress()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {_uniqueStorage()._address = nil}

  public var properties: [IdentityStateProperty] {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  public var companyEngagements: [IdentityStateCompanyEngagement] {
    get {return _storage._companyEngagements}
    set {_uniqueStorage()._companyEngagements = newValue}
  }

  public var creditScore: IdentityStateCreditScore {
    get {return _storage._creditScore ?? IdentityStateCreditScore()}
    set {_uniqueStorage()._creditScore = newValue}
  }
  /// Returns true if `creditScore` has been explicitly set.
  public var hasCreditScore: Bool {return _storage._creditScore != nil}
  /// Clears the value of `creditScore`. Subsequent reads from it will return its default value.
  public mutating func clearCreditScore() {_uniqueStorage()._creditScore = nil}

  public var mostRecentTaxDeclaration: IdentityStateTaxDeclaration {
    get {return _storage._mostRecentTaxDeclaration ?? IdentityStateTaxDeclaration()}
    set {_uniqueStorage()._mostRecentTaxDeclaration = newValue}
  }
  /// Returns true if `mostRecentTaxDeclaration` has been explicitly set.
  public var hasMostRecentTaxDeclaration: Bool {return _storage._mostRecentTaxDeclaration != nil}
  /// Clears the value of `mostRecentTaxDeclaration`. Subsequent reads from it will return its default value.
  public mutating func clearMostRecentTaxDeclaration() {_uniqueStorage()._mostRecentTaxDeclaration = nil}

  public var recordsOfNonPayment: [IdentityStateRecordOfNonPayment] {
    get {return _storage._recordsOfNonPayment}
    set {_uniqueStorage()._recordsOfNonPayment = newValue}
  }

  public var outstandingDebt: IdentityStateOutstandingDebt {
    get {return _storage._outstandingDebt ?? IdentityStateOutstandingDebt()}
    set {_uniqueStorage()._outstandingDebt = newValue}
  }
  /// Returns true if `outstandingDebt` has been explicitly set.
  public var hasOutstandingDebt: Bool {return _storage._outstandingDebt != nil}
  /// Clears the value of `outstandingDebt`. Subsequent reads from it will return its default value.
  public mutating func clearOutstandingDebt() {_uniqueStorage()._outstandingDebt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IdentityDocumentedAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var answer: IdentityAnswerKey = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Consent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var version: String = String()

  public var title: String = String()

  public var body: String = String()

  public var checksum: String = String()

  public var messages: [ConsentMessage] = []

  public var attachments: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserConsent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  public var action: ConsentAction {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ConsentMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var links: [ConsentMessageLink] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ConsentMessageLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var to: String = String()

  public var start: Int32 = 0

  public var end: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ThirdPartyAppAuthentication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var downloadTitle: String {
    get {return _storage._downloadTitle}
    set {_uniqueStorage()._downloadTitle = newValue}
  }

  public var downloadMessage: String {
    get {return _storage._downloadMessage}
    set {_uniqueStorage()._downloadMessage = newValue}
  }

  public var upgradeTitle: String {
    get {return _storage._upgradeTitle}
    set {_uniqueStorage()._upgradeTitle = newValue}
  }

  public var upgradeMessage: String {
    get {return _storage._upgradeMessage}
    set {_uniqueStorage()._upgradeMessage = newValue}
  }

  public var ios: ThirdPartyAppAuthentication.Ios {
    get {return _storage._ios ?? ThirdPartyAppAuthentication.Ios()}
    set {_uniqueStorage()._ios = newValue}
  }
  /// Returns true if `ios` has been explicitly set.
  public var hasIos: Bool {return _storage._ios != nil}
  /// Clears the value of `ios`. Subsequent reads from it will return its default value.
  public mutating func clearIos() {_uniqueStorage()._ios = nil}

  public var android: ThirdPartyAppAuthentication.Android {
    get {return _storage._android ?? ThirdPartyAppAuthentication.Android()}
    set {_uniqueStorage()._android = newValue}
  }
  /// Returns true if `android` has been explicitly set.
  public var hasAndroid: Bool {return _storage._android != nil}
  /// Clears the value of `android`. Subsequent reads from it will return its default value.
  public mutating func clearAndroid() {_uniqueStorage()._android = nil}

  public var web: ThirdPartyAppAuthentication.Web {
    get {return _storage._web ?? ThirdPartyAppAuthentication.Web()}
    set {_uniqueStorage()._web = newValue}
  }
  /// Returns true if `web` has been explicitly set.
  public var hasWeb: Bool {return _storage._web != nil}
  /// Clears the value of `web`. Subsequent reads from it will return its default value.
  public mutating func clearWeb() {_uniqueStorage()._web = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Ios {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var appStoreURL: String = String()

    public var scheme: String = String()

    public var deepLinkURL: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Android {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var packageName: String = String()

    public var requiredMinimumVersion: Int32 = 0

    public var intent: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Web {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var url: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Wrap lists in objects, Only used in streaming
/// Since we stream lists, we have to encapsulate them in objects so we can see the difference between empty lists that need action and those that don't
public struct Credentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var credential: [Credential] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Accounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: [Account] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Transactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transaction: [Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Providers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var provider: [Provider] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Periods {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var period: Dictionary<String,Period> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FollowItems {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var followItem: [FollowItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SignableOperations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signableOperation: [SignableOperation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BudgetSummaries {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var budgetSummaries: [Budget.Summary] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Insights {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var insights: [Insight] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InsightsCategories {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var body: String = String()

  public var amountByCategoryCode: [InsightsCategories.AmountByCategoryCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct AmountByCategoryCode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var categoryCode: String {
      get {return _storage._categoryCode}
      set {_uniqueStorage()._categoryCode = newValue}
    }

    public var amount: CurrencyDenominatedAmount {
      get {return _storage._amount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    public var hasAmount: Bool {return _storage._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    public mutating func clearAmount() {_uniqueStorage()._amount = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

public struct InsightsMortgage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var body: String = String()

  public var distribution: [InsightsMortgage.HistogramBucket] = []

  public var interestRate: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct HistogramBucket {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var lowerEndpoint: Double = 0

    public var upperEndpoint: Double = 0

    public var frequency: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct InsightsSavings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var body: String {
    get {return _storage._body}
    set {_uniqueStorage()._body = newValue}
  }

  public var amount: CurrencyDenominatedAmount {
    get {return _storage._amount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct InsightsDailySpend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var body: String = String()

  public var amountByWeekday: [InsightsDailySpend.AmountByWeekday] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct AmountByWeekday {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var weekday: String {
      get {return _storage._weekday}
      set {_uniqueStorage()._weekday = newValue}
    }

    public var amount: CurrencyDenominatedAmount {
      get {return _storage._amount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    public var hasAmount: Bool {return _storage._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    public mutating func clearAmount() {_uniqueStorage()._amount = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

public struct InsightsLeftToSpend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var body: String = String()

  public var leftToSpendByPeriod: [InsightsLeftToSpend.LeftToSpendByPeriod] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct LeftToSpendByPeriod {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var period: String = String()

    public var percentage: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Application {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var forms: ApplicationForms {
    get {return _storage._forms ?? ApplicationForms()}
    set {_uniqueStorage()._forms = newValue}
  }
  /// Returns true if `forms` has been explicitly set.
  public var hasForms: Bool {return _storage._forms != nil}
  /// Clears the value of `forms`. Subsequent reads from it will return its default value.
  public mutating func clearForms() {_uniqueStorage()._forms = nil}

  public var status: ApplicationStatus {
    get {return _storage._status ?? ApplicationStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var steps: Int32 {
    get {return _storage._steps}
    set {_uniqueStorage()._steps = newValue}
  }

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var type: ApplicationType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ApplicationSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var imageURL: String {
    get {return _storage._imageURL}
    set {_uniqueStorage()._imageURL = newValue}
  }

  public var progress: Double {
    get {return _storage._progress}
    set {_uniqueStorage()._progress = newValue}
  }

  public var provider: String {
    get {return _storage._provider}
    set {_uniqueStorage()._provider = newValue}
  }

  public var status: ApplicationSummaryStatus {
    get {return _storage._status ?? ApplicationSummaryStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var type: ApplicationType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ApplicationSummaryStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: ApplicationStatusKey = .applicationStatusUnknown

  public var body: String = String()

  public var payload: String = String()

  public var title: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ApplicationForms {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var form: [ApplicationForm] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ApplicationForm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var applicationID: String {
    get {return _storage._applicationID}
    set {_uniqueStorage()._applicationID = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var fields: ApplicationFormFields {
    get {return _storage._fields ?? ApplicationFormFields()}
    set {_uniqueStorage()._fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  public var hasFields: Bool {return _storage._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  public mutating func clearFields() {_uniqueStorage()._fields = nil}

  public var status: ApplicationFormStatus {
    get {return _storage._status ?? ApplicationFormStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var serializedPayload: String {
    get {return _storage._serializedPayload}
    set {_uniqueStorage()._serializedPayload = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct RequestApplicationForm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var fields: RequestApplicationFormFields {
    get {return _storage._fields ?? RequestApplicationFormFields()}
    set {_uniqueStorage()._fields = newValue}
  }
  /// Returns true if `fields` has been explicitly set.
  public var hasFields: Bool {return _storage._fields != nil}
  /// Clears the value of `fields`. Subsequent reads from it will return its default value.
  public mutating func clearFields() {_uniqueStorage()._fields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct RequestApplicationFormFields {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: [RequestApplicationFormField] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RequestApplicationFormField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var value: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._value ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ApplicationFormFields {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: [ApplicationFormField] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ApplicationFormField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var defaultValue: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._defaultValue ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._defaultValue = newValue}
  }
  /// Returns true if `defaultValue` has been explicitly set.
  public var hasDefaultValue: Bool {return _storage._defaultValue != nil}
  /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultValue() {_uniqueStorage()._defaultValue = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var errors: ApplicationFormFieldErrors {
    get {return _storage._errors ?? ApplicationFormFieldErrors()}
    set {_uniqueStorage()._errors = newValue}
  }
  /// Returns true if `errors` has been explicitly set.
  public var hasErrors: Bool {return _storage._errors != nil}
  /// Clears the value of `errors`. Subsequent reads from it will return its default value.
  public mutating func clearErrors() {_uniqueStorage()._errors = nil}

  public var displayError: String {
    get {return _storage._displayError}
    set {_uniqueStorage()._displayError = newValue}
  }

  public var label: String {
    get {return _storage._label}
    set {_uniqueStorage()._label = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var options: ApplicationFormFieldOptions {
    get {return _storage._options ?? ApplicationFormFieldOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {_uniqueStorage()._options = nil}

  public var pattern: String {
    get {return _storage._pattern}
    set {_uniqueStorage()._pattern = newValue}
  }

  public var type: ApplicationFieldType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var value: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._value ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var required: Bool {
    get {return _storage._required}
    set {_uniqueStorage()._required = newValue}
  }

  public var readOnly: Bool {
    get {return _storage._readOnly}
    set {_uniqueStorage()._readOnly = newValue}
  }

  public var dependency: String {
    get {return _storage._dependency}
    set {_uniqueStorage()._dependency = newValue}
  }

  public var infoTitle: String {
    get {return _storage._infoTitle}
    set {_uniqueStorage()._infoTitle = newValue}
  }

  public var infoBody: String {
    get {return _storage._infoBody}
    set {_uniqueStorage()._infoBody = newValue}
  }

  public var introduction: String {
    get {return _storage._introduction}
    set {_uniqueStorage()._introduction = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ApplicationFormFieldOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: [ApplicationFormFieldOption] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ApplicationFormFieldOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var label: String = String()

  public var description_p: String = String()

  public var serializedPayload: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ApplicationFormFieldErrors {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: [ApplicationFormFieldError] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ApplicationFormFieldError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ApplicationStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: ApplicationStatusKey {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  public var hasUpdated: Bool {return _storage._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  public mutating func clearUpdated() {_uniqueStorage()._updated = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ApplicationFormStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: ApplicationFormStatusKey {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var updated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  public var hasUpdated: Bool {return _storage._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  public mutating func clearUpdated() {_uniqueStorage()._updated = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BusinessDays {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var year: UInt32 = 0

  public var month: UInt32 = 0

  public var days: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ErrorCode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Property {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var propertyID: String {
    get {return _storage._propertyID}
    set {_uniqueStorage()._propertyID = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var postalCode: String {
    get {return _storage._postalCode}
    set {_uniqueStorage()._postalCode = newValue}
  }

  public var city: String {
    get {return _storage._city}
    set {_uniqueStorage()._city = newValue}
  }

  public var community: String {
    get {return _storage._community}
    set {_uniqueStorage()._community = newValue}
  }

  public var latitude: Double {
    get {return _storage._latitude}
    set {_uniqueStorage()._latitude = newValue}
  }

  public var longitude: Double {
    get {return _storage._longitude}
    set {_uniqueStorage()._longitude = newValue}
  }

  public var type: Property.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var numberOfRooms: Int32 {
    get {return _storage._numberOfRooms}
    set {_uniqueStorage()._numberOfRooms = newValue}
  }

  public var numberOfSquareMeters: Int32 {
    get {return _storage._numberOfSquareMeters}
    set {_uniqueStorage()._numberOfSquareMeters = newValue}
  }

  /// Deprecated, use "valuation_amount"
  public var valuation: Int32 {
    get {return _storage._valuation}
    set {_uniqueStorage()._valuation = newValue}
  }

  public var loanAccountIds: [String] {
    get {return _storage._loanAccountIds}
    set {_uniqueStorage()._loanAccountIds = newValue}
  }

  public var registeredAddress: Bool {
    get {return _storage._registeredAddress}
    set {_uniqueStorage()._registeredAddress = newValue}
  }

  public var userModifiedLoanAccountIds: Bool {
    get {return _storage._userModifiedLoanAccountIds}
    set {_uniqueStorage()._userModifiedLoanAccountIds = newValue}
  }

  public var valuationAmount: CurrencyDenominatedAmount {
    get {return _storage._valuationAmount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._valuationAmount = newValue}
  }
  /// Returns true if `valuationAmount` has been explicitly set.
  public var hasValuationAmount: Bool {return _storage._valuationAmount != nil}
  /// Clears the value of `valuationAmount`. Subsequent reads from it will return its default value.
  public mutating func clearValuationAmount() {_uniqueStorage()._valuationAmount = nil}

  public var totalLoanAmount: CurrencyDenominatedAmount {
    get {return _storage._totalLoanAmount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._totalLoanAmount = newValue}
  }
  /// Returns true if `totalLoanAmount` has been explicitly set.
  public var hasTotalLoanAmount: Bool {return _storage._totalLoanAmount != nil}
  /// Clears the value of `totalLoanAmount`. Subsequent reads from it will return its default value.
  public mutating func clearTotalLoanAmount() {_uniqueStorage()._totalLoanAmount = nil}

  public var averageInterestRate: ExactNumber {
    get {return _storage._averageInterestRate ?? ExactNumber()}
    set {_uniqueStorage()._averageInterestRate = newValue}
  }
  /// Returns true if `averageInterestRate` has been explicitly set.
  public var hasAverageInterestRate: Bool {return _storage._averageInterestRate != nil}
  /// Clears the value of `averageInterestRate`. Subsequent reads from it will return its default value.
  public mutating func clearAverageInterestRate() {_uniqueStorage()._averageInterestRate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case propertyTypeUnknown // = 0
    case propertyTypeHouse // = 1
    case propertyTypeApartment // = 2
    case propertyTypeVacationHouse // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .propertyTypeUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .propertyTypeUnknown
      case 1: self = .propertyTypeHouse
      case 2: self = .propertyTypeApartment
      case 3: self = .propertyTypeVacationHouse
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .propertyTypeUnknown: return 0
      case .propertyTypeHouse: return 1
      case .propertyTypeApartment: return 2
      case .propertyTypeVacationHouse: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Property.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Property.TypeEnum] = [
    .propertyTypeUnknown,
    .propertyTypeHouse,
    .propertyTypeApartment,
    .propertyTypeVacationHouse,
  ]
}

#endif  // swift(>=4.2)

public struct Market {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var label: String = String()

  public var status: MarketStatus = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProviderMarket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PropertyValuationEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var propertyID: String {
    get {return _storage._propertyID}
    set {_uniqueStorage()._propertyID = newValue}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var valuationAmount: CurrencyDenominatedAmount {
    get {return _storage._valuationAmount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._valuationAmount = newValue}
  }
  /// Returns true if `valuationAmount` has been explicitly set.
  public var hasValuationAmount: Bool {return _storage._valuationAmount != nil}
  /// Clears the value of `valuationAmount`. Subsequent reads from it will return its default value.
  public mutating func clearValuationAmount() {_uniqueStorage()._valuationAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct PropertyValuationSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var propertyID: String {
    get {return _storage._propertyID}
    set {_uniqueStorage()._propertyID = newValue}
  }

  public var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return _storage._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {_uniqueStorage()._from = nil}

  public var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  public var hasTo: Bool {return _storage._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  public mutating func clearTo() {_uniqueStorage()._to = nil}

  public var fromValuationAmount: CurrencyDenominatedAmount {
    get {return _storage._fromValuationAmount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._fromValuationAmount = newValue}
  }
  /// Returns true if `fromValuationAmount` has been explicitly set.
  public var hasFromValuationAmount: Bool {return _storage._fromValuationAmount != nil}
  /// Clears the value of `fromValuationAmount`. Subsequent reads from it will return its default value.
  public mutating func clearFromValuationAmount() {_uniqueStorage()._fromValuationAmount = nil}

  public var toValuationAmount: CurrencyDenominatedAmount {
    get {return _storage._toValuationAmount ?? CurrencyDenominatedAmount()}
    set {_uniqueStorage()._toValuationAmount = newValue}
  }
  /// Returns true if `toValuationAmount` has been explicitly set.
  public var hasToValuationAmount: Bool {return _storage._toValuationAmount != nil}
  /// Clears the value of `toValuationAmount`. Subsequent reads from it will return its default value.
  public mutating func clearToValuationAmount() {_uniqueStorage()._toValuationAmount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Insight {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var group: InsightGroup {
    get {return _storage._group}
    set {_uniqueStorage()._group = newValue}
  }

  public var score: ExactNumber {
    get {return _storage._score ?? ExactNumber()}
    set {_uniqueStorage()._score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return _storage._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {_uniqueStorage()._score = nil}

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_uniqueStorage()._created = nil}

  public var expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expirationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expirationDate = newValue}
  }
  /// Returns true if `expirationDate` has been explicitly set.
  public var hasExpirationDate: Bool {return _storage._expirationDate != nil}
  /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationDate() {_uniqueStorage()._expirationDate = nil}

  public var dataSets: [InsightDataSet] {
    get {return _storage._dataSets}
    set {_uniqueStorage()._dataSets = newValue}
  }

  public var actions: [InsightAction] {
    get {return _storage._actions}
    set {_uniqueStorage()._actions = newValue}
  }

  public var referenceIds: [ReferenceId] {
    get {return _storage._referenceIds}
    set {_uniqueStorage()._referenceIds = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ArchivedInsight {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var group: InsightGroup {
    get {return _storage._group}
    set {_uniqueStorage()._group = newValue}
  }

  public var score: ExactNumber {
    get {return _storage._score ?? ExactNumber()}
    set {_uniqueStorage()._score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return _storage._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {_uniqueStorage()._score = nil}

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var insightCreatedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._insightCreatedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._insightCreatedDate = newValue}
  }
  /// Returns true if `insightCreatedDate` has been explicitly set.
  public var hasInsightCreatedDate: Bool {return _storage._insightCreatedDate != nil}
  /// Clears the value of `insightCreatedDate`. Subsequent reads from it will return its default value.
  public mutating func clearInsightCreatedDate() {_uniqueStorage()._insightCreatedDate = nil}

  public var insightArchivedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._insightArchivedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._insightArchivedDate = newValue}
  }
  /// Returns true if `insightArchivedDate` has been explicitly set.
  public var hasInsightArchivedDate: Bool {return _storage._insightArchivedDate != nil}
  /// Clears the value of `insightArchivedDate`. Subsequent reads from it will return its default value.
  public mutating func clearInsightArchivedDate() {_uniqueStorage()._insightArchivedDate = nil}

  public var dataSets: [InsightDataSet] {
    get {return _storage._dataSets}
    set {_uniqueStorage()._dataSets = newValue}
  }

  public var action: InsightAction {
    get {return _storage._action ?? InsightAction()}
    set {_uniqueStorage()._action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return _storage._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {_uniqueStorage()._action = nil}

  public var referenceIds: [ReferenceId] {
    get {return _storage._referenceIds}
    set {_uniqueStorage()._referenceIds = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct InsightDataSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var dataSeries: [InsightDataSet.DataSeries] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataSeries {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var type: String = String()

    public var dataPoints: [InsightDataSet.DataSeries.DataPoint] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct DataPoint {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var x: Double = 0

      public var y: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

public struct InsightAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var label: String = String()

  public var target: String = String()

  public var type: InsightAction.TypeEnum = .unknown

  public var method: InsightAction.Method = .unknown

  public var group: InsightGroup = .groupUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case primary // = 1
    case secondary // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .primary
      case 2: self = .secondary
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .primary: return 1
      case .secondary: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Method: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case acknowledge // = 1
    case create // = 2
    case add // = 3
    case goTo // = 4
    case edit // = 5
    case notNow // = 6
    case dismiss // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .acknowledge
      case 2: self = .create
      case 3: self = .add
      case 4: self = .goTo
      case 5: self = .edit
      case 6: self = .notNow
      case 7: self = .dismiss
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .acknowledge: return 1
      case .create: return 2
      case .add: return 3
      case .goTo: return 4
      case .edit: return 5
      case .notNow: return 6
      case .dismiss: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension InsightAction.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [InsightAction.TypeEnum] = [
    .unknown,
    .primary,
    .secondary,
  ]
}

extension InsightAction.Method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [InsightAction.Method] = [
    .unknown,
    .acknowledge,
    .create,
    .add,
    .goTo,
    .edit,
    .notNow,
    .dismiss,
  ]
}

#endif  // swift(>=4.2)

public struct ReferenceId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: ReferenceId.TypeEnum = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case account // = 1
    case budget // = 2
    case credentials // = 3
    case savingsGoal // = 4
    case transaction // = 5
    case transfer // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .account
      case 2: self = .budget
      case 3: self = .credentials
      case 4: self = .savingsGoal
      case 5: self = .transaction
      case 6: self = .transfer
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .account: return 1
      case .budget: return 2
      case .credentials: return 3
      case .savingsGoal: return 4
      case .transaction: return 5
      case .transfer: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension ReferenceId.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ReferenceId.TypeEnum] = [
    .unknown,
    .account,
    .budget,
    .credentials,
    .savingsGoal,
    .transaction,
    .transfer,
  ]
}

#endif  // swift(>=4.2)

public struct RecurringTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Transaction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transactionID: String {
      get {return _storage._transactionID}
      set {_uniqueStorage()._transactionID = newValue}
    }

    public var type: RecurringTransaction.Transaction.TypeEnum {
      get {return _storage._type}
      set {_uniqueStorage()._type = newValue}
    }

    public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    public var hasDate: Bool {return _storage._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    public mutating func clearDate() {_uniqueStorage()._date = nil}

    public var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    public var amount: CurrencyDenominatedAmount {
      get {return _storage._amount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    public var hasAmount: Bool {return _storage._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    public mutating func clearAmount() {_uniqueStorage()._amount = nil}

    public var category: RecurringTransaction.Category {
      get {return _storage._category ?? RecurringTransaction.Category()}
      set {_uniqueStorage()._category = newValue}
    }
    /// Returns true if `category` has been explicitly set.
    public var hasCategory: Bool {return _storage._category != nil}
    /// Clears the value of `category`. Subsequent reads from it will return its default value.
    public mutating func clearCategory() {_uniqueStorage()._category = nil}

    public var groupID: String {
      get {return _storage._groupID}
      set {_uniqueStorage()._groupID = newValue}
    }

    public var source: RecurringTransaction.Transaction.Source {
      get {return _storage._source}
      set {_uniqueStorage()._source = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0
      case predicted // = 1
      case existing // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .predicted
        case 2: self = .existing
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .predicted: return 1
        case .existing: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public enum Source: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0
      case userAdded // = 1
      case generated // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .userAdded
        case 2: self = .generated
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .userAdded: return 1
        case .generated: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Category {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: RecurringTransaction.Category.TypeEnum = .unknown

    public var code: String = String()

    public var primaryName: String = String()

    public var secondaryName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0
      case income // = 1
      case expense // = 2
      case transfer // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .income
        case 2: self = .expense
        case 3: self = .transfer
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .income: return 1
        case .expense: return 2
        case .transfer: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct Group {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String = String()

    public var name: String = String()

    public var qualifier: String = String()

    public var periodicity: RecurringTransaction.Group.RecurringPeriodicity = .unknown

    public var categoryType: RecurringTransaction.Category.TypeEnum = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum State: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0
      case disabled // = 1
      case active // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .disabled
        case 2: self = .active
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .disabled: return 1
        case .active: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public enum RecurringPeriodicity: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0
      case monthly // = 1
      case quarterly // = 2
      case yearly // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .monthly
        case 2: self = .quarterly
        case 3: self = .yearly
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .monthly: return 1
        case .quarterly: return 2
        case .yearly: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct PeriodSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var totalAmount: CurrencyDenominatedAmount {
      get {return _storage._totalAmount ?? CurrencyDenominatedAmount()}
      set {_uniqueStorage()._totalAmount = newValue}
    }
    /// Returns true if `totalAmount` has been explicitly set.
    public var hasTotalAmount: Bool {return _storage._totalAmount != nil}
    /// Clears the value of `totalAmount`. Subsequent reads from it will return its default value.
    public mutating func clearTotalAmount() {_uniqueStorage()._totalAmount = nil}

    public var start: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    public var hasStart: Bool {return _storage._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    public mutating func clearStart() {_uniqueStorage()._start = nil}

    public var end: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    public var hasEnd: Bool {return _storage._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    public mutating func clearEnd() {_uniqueStorage()._end = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

public struct KycQuestion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reference: String = String()

  public var answer: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MarketStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MARKET_STATUS_UNKNOWN"),
    1: .same(proto: "MARKET_STATUS_BETA"),
    2: .same(proto: "MARKET_STATUS_DISABLED"),
    3: .same(proto: "MARKET_STATUS_ENABLED"),
  ]
}

extension PeriodDateBreakType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERIOD_DATE_BREAK_TYPE_UNKNOWN"),
    1: .same(proto: "PERIOD_DATE_BREAK_TYPE_MONTHLY"),
    2: .same(proto: "PERIOD_DATE_BREAK_TYPE_MONTHLY_ADJUSTED"),
  ]
}

extension PeriodMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERIOD_MODE_UNKNOWN"),
    1: .same(proto: "PERIOD_MODE_DAILY"),
    2: .same(proto: "PERIOD_MODE_MONTHLY"),
    3: .same(proto: "PERIOD_MODE_WEEKLY"),
    4: .same(proto: "PERIOD_MODE_YEARLY"),
    5: .same(proto: "PERIOD_MODE_ALL"),
  ]
}

extension BankIdAuthenticationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BANK_ID_AUTHENTICATION_STATUS_UNKNOWN"),
    1: .same(proto: "BANK_ID_AUTHENTICATION_STATUS_AUTHENTICATED"),
    2: .same(proto: "BANK_ID_AUTHENTICATION_STATUS_AUTHENTICATION_ERROR"),
    3: .same(proto: "BANK_ID_AUTHENTICATION_STATUS_AWAITING_BANKID_AUTHENTICATION"),
    4: .same(proto: "BANK_ID_AUTHENTICATION_STATUS_NO_USER"),
  ]
}

extension AuthenticationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATION_STATUS_UNKNOWN"),
    1: .same(proto: "AUTHENTICATION_STATUS_AUTHENTICATED"),
    2: .same(proto: "AUTHENTICATION_STATUS_AUTHENTICATION_ERROR"),
    4: .same(proto: "AUTHENTICATION_STATUS_NO_USER"),
    5: .same(proto: "AUTHENTICATION_STATUS_USER_BLOCKED"),
    6: .same(proto: "AUTHENTICATION_STATUS_AUTHENTICATED_UNAUTHORIZED_DEVICE"),
    7: .same(proto: "AUTHENTICATION_STATUS_AUTHENTICATION_ERROR_UNAUTHORIZED_DEVICE"),
  ]
}

extension AuthenticationKeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_TYPE_UNKNOWN"),
    1: .same(proto: "KEY_TYPE_RSA"),
    2: .same(proto: "KEY_TYPE_ECDSA"),
  ]
}

extension AuthenticationSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATION_SOURCE_UNKNOWN"),
    1: .same(proto: "AUTHENTICATION_SOURCE_TOUCHID"),
    2: .same(proto: "AUTHENTICATION_SOURCE_FINGERPRINT"),
    3: .same(proto: "AUTHENTICATION_SOURCE_FACEID"),
  ]
}

extension IdentityAnswerKey: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IDENTITY_ANSWER_KEY_UNKNOWN"),
    1: .same(proto: "IDENTITY_ANSWER_KEY_OK"),
    2: .same(proto: "IDENTITY_ANSWER_KEY_FRAUDULENT"),
  ]
}

extension ConsentAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONSENT_ACTION_UNKNOWN"),
    1: .same(proto: "CONSENT_ACTION_ACCEPTED"),
    2: .same(proto: "CONSENT_ACTION_DECLINED"),
  ]
}

extension SmsOtpStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SMS_OTP_STATUS_UNKNOWN"),
    1: .same(proto: "SMS_OTP_STATUS_CORRECT"),
    2: .same(proto: "SMS_OTP_STATUS_INCORRECT"),
    3: .same(proto: "SMS_OTP_STATUS_EXPIRED"),
    4: .same(proto: "SMS_OTP_STATUS_TOO_MANY_ATTEMPTS"),
  ]
}

extension RateAppStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RATE_APP_STATUS_UNKNOWN"),
    1: .same(proto: "RATE_APP_STATUS_CLICKED_IGNORE"),
    2: .same(proto: "RATE_APP_STATUS_CLICKED_RATE_IN_STORE"),
  ]
}

extension AuthenticationMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATION_METHOD_UNKNOWN"),
    1: .same(proto: "AUTHENTICATION_METHOD_BANKID"),
    2: .same(proto: "AUTHENTICATION_METHOD_EMAIL_AND_PASSWORD"),
    3: .same(proto: "AUTHENTICATION_METHOD_SMS_OTP_AND_PIN6"),
    4: .same(proto: "AUTHENTICATION_METHOD_PHONE_NUMBER_AND_PIN6"),
    5: .same(proto: "AUTHENTICATION_METHOD_ABN_AMRO_PIN5"),
  ]
}

extension ApplicationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APPLICATION_TYPE_UNKNOWN"),
    1: .same(proto: "APPLICATION_TYPE_SWITCH_MORTGAGE_PROVIDER"),
    2: .same(proto: "APPLICATION_TYPE_OPEN_SAVINGS_ACCOUNT"),
    3: .same(proto: "APPLICATION_TYPE_RESIDENCE_VALUATION"),
    4: .same(proto: "APPLICATION_TYPE_SOLICIT_UNSECURED_LOANS"),
    5: .same(proto: "APPLICATION_TYPE_ACCEPT_UNSECURED_LOANS"),
  ]
}

extension ApplicationFieldType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APPLICATION_FIELD_TYPE_UNKNOWN"),
    1: .same(proto: "APPLICATION_FIELD_TYPE_CHECKBOX"),
    2: .same(proto: "APPLICATION_FIELD_TYPE_DATE"),
    3: .same(proto: "APPLICATION_FIELD_TYPE_EMAIL"),
    4: .same(proto: "APPLICATION_FIELD_TYPE_HIDDEN"),
    5: .same(proto: "APPLICATION_FIELD_TYPE_MULTI_SELECT"),
    6: .same(proto: "APPLICATION_FIELD_TYPE_NUMBER"),
    7: .same(proto: "APPLICATION_FIELD_TYPE_NUMERIC"),
    8: .same(proto: "APPLICATION_FIELD_TYPE_SELECT"),
    9: .same(proto: "APPLICATION_FIELD_TYPE_SIGNATURE"),
    10: .same(proto: "APPLICATION_FIELD_TYPE_TEXT"),
  ]
}

extension ApplicationStatusKey: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APPLICATION_STATUS_UNKNOWN"),
    1: .same(proto: "APPLICATION_STATUS_CREATED"),
    2: .same(proto: "APPLICATION_STATUS_IN_PROGRESS"),
    3: .same(proto: "APPLICATION_STATUS_DELETED"),
    4: .same(proto: "APPLICATION_STATUS_ERROR"),
    5: .same(proto: "APPLICATION_STATUS_EXPIRED"),
    6: .same(proto: "APPLICATION_STATUS_DISQUALIFIED"),
    7: .same(proto: "APPLICATION_STATUS_COMPLETED"),
    8: .same(proto: "APPLICATION_STATUS_SIGNED"),
    9: .same(proto: "APPLICATION_STATUS_SUPPLEMENTAL_INFORMATION_REQUIRED"),
    10: .same(proto: "APPLICATION_STATUS_REJECTED"),
    11: .same(proto: "APPLICATION_STATUS_APPROVED"),
    12: .same(proto: "APPLICATION_STATUS_ABORTED"),
    13: .same(proto: "APPLICATION_STATUS_EXECUTED"),
    14: .same(proto: "APPLICATION_STATUS_PENDING"),
  ]
}

extension ApplicationFormStatusKey: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APPLICATION_FORM_STATUS_UNKNOWN"),
    1: .same(proto: "APPLICATION_FORM_STATUS_CREATED"),
    2: .same(proto: "APPLICATION_FORM_STATUS_COMPLETED"),
    3: .same(proto: "APPLICATION_FORM_STATUS_IN_PROGRESS"),
    4: .same(proto: "APPLICATION_FORM_STATUS_ERROR"),
    5: .same(proto: "APPLICATION_FORM_STATUS_DISQUALIFIED"),
    6: .same(proto: "APPLICATION_FORM_STATUS_AUTO_SAVED"),
  ]
}

extension InsightGroup: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GROUP_UNKNOWN"),
    1: .same(proto: "GROUP_EDUCATING"),
    2: .same(proto: "GROUP_ENCOURAGING"),
    3: .same(proto: "GROUP_FUN_FACT"),
    4: .same(proto: "GROUP_PRODUCT_SUGGEST"),
    5: .same(proto: "GROUP_PROMOTION"),
    6: .same(proto: "GROUP_REMINDER"),
    7: .same(proto: "GROUP_SOURCE_DATA"),
    8: .same(proto: "GROUP_SUGGESTION"),
    9: .same(proto: "GROUP_SUMMARY"),
    10: .same(proto: "GROUP_WARNING"),
    11: .same(proto: "GROUP_BUDGET"),
    12: .same(proto: "GROUP_ACCOUNT"),
    13: .same(proto: "GROUP_CATEGORIZATION"),
    14: .same(proto: "GROUP_CREDENTIALS"),
    15: .same(proto: "GROUP_INVOICE"),
    16: .same(proto: "GROUP_FRAUD"),
    17: .same(proto: "GROUP_LEFT_TO_SPEND"),
  ]
}

extension SortType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SORT_TYPE_UNKNOWN"),
    1: .same(proto: "SORT_TYPE_SCORE"),
    2: .same(proto: "SORT_TYPE_DATE"),
    3: .same(proto: "SORT_TYPE_ACCOUNT"),
    4: .same(proto: "SORT_TYPE_DESCRIPTION"),
    5: .same(proto: "SORT_TYPE_AMOUNT"),
    6: .same(proto: "SORT_TYPE_CATEGORY"),
  ]
}

extension OrderType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_TYPE_UNKNOWN"),
    1: .same(proto: "ORDER_TYPE_ASC"),
    2: .same(proto: "ORDER_TYPE_DESC"),
  ]
}

extension Theme: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "THEME_UNKNOWN"),
    1: .same(proto: "THEME_LIGHT"),
    2: .same(proto: "THEME_BLACK"),
    3: .same(proto: "THEME_DARK"),
  ]
}

extension Credential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Credential"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "provider_name"),
    3: .same(proto: "type"),
    4: .same(proto: "status"),
    5: .standard(proto: "status_payload"),
    6: .standard(proto: "status_updated"),
    7: .same(proto: "updated"),
    8: .same(proto: "fields"),
    9: .standard(proto: "supplemental_information_fields"),
    10: .standard(proto: "third_party_app_authentication"),
    11: .same(proto: "sessionExpiryDate"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _providerName: String = String()
    var _type: Credential.TypeEnum = .unknown
    var _status: Credential.Status = .unknown
    var _statusPayload: String = String()
    var _statusUpdated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _fields: Dictionary<String,String> = [:]
    var _supplementalInformationFields: [ProviderFieldSpecification] = []
    var _thirdPartyAppAuthentication: ThirdPartyAppAuthentication? = nil
    var _sessionExpiryDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _providerName = source._providerName
      _type = source._type
      _status = source._status
      _statusPayload = source._statusPayload
      _statusUpdated = source._statusUpdated
      _updated = source._updated
      _fields = source._fields
      _supplementalInformationFields = source._supplementalInformationFields
      _thirdPartyAppAuthentication = source._thirdPartyAppAuthentication
      _sessionExpiryDate = source._sessionExpiryDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._providerName)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 5: try decoder.decodeSingularStringField(value: &_storage._statusPayload)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._statusUpdated)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._updated)
        case 8: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._fields)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._supplementalInformationFields)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._thirdPartyAppAuthentication)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._sessionExpiryDate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._providerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._providerName, fieldNumber: 2)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      if _storage._status != .unknown {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 4)
      }
      if !_storage._statusPayload.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusPayload, fieldNumber: 5)
      }
      if let v = _storage._statusUpdated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._updated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._fields.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._fields, fieldNumber: 8)
      }
      if !_storage._supplementalInformationFields.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._supplementalInformationFields, fieldNumber: 9)
      }
      if let v = _storage._thirdPartyAppAuthentication {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._sessionExpiryDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Credential, rhs: Credential) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._providerName != rhs_storage._providerName {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusPayload != rhs_storage._statusPayload {return false}
        if _storage._statusUpdated != rhs_storage._statusUpdated {return false}
        if _storage._updated != rhs_storage._updated {return false}
        if _storage._fields != rhs_storage._fields {return false}
        if _storage._supplementalInformationFields != rhs_storage._supplementalInformationFields {return false}
        if _storage._thirdPartyAppAuthentication != rhs_storage._thirdPartyAppAuthentication {return false}
        if _storage._sessionExpiryDate != rhs_storage._sessionExpiryDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Credential.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_CREATED"),
    2: .same(proto: "STATUS_AUTHENTICATING"),
    3: .same(proto: "STATUS_UPDATING"),
    4: .same(proto: "STATUS_UPDATED"),
    5: .same(proto: "STATUS_TEMPORARY_ERROR"),
    6: .same(proto: "STATUS_AUTHENTICATION_ERROR"),
    7: .same(proto: "STATUS_PERMANENT_ERROR"),
    8: .same(proto: "STATUS_AWAITING_MOBILE_BANKID_AUTHENTICATION"),
    9: .same(proto: "STATUS_AWAITING_SUPPLEMENTAL_INFORMATION"),
    10: .same(proto: "STATUS_DISABLED"),
    11: .same(proto: "STATUS_AWAITING_THIRD_PARTY_APP_AUTHENTICATION"),
    12: .same(proto: "STATUS_SESSION_EXPIRED"),
  ]
}

extension Credential.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_PASSWORD"),
    2: .same(proto: "TYPE_MOBILE_BANKID"),
    3: .same(proto: "TYPE_KEYFOB"),
    4: .same(proto: "TYPE_FRAUD"),
    5: .same(proto: "TYPE_THIRD_PARTY_AUTHENTICATION"),
  ]
}

extension Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Account"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "balance"),
    3: .standard(proto: "account_number"),
    4: .standard(proto: "credential_id"),
    5: .same(proto: "excluded"),
    6: .same(proto: "favored"),
    7: .same(proto: "transactional"),
    8: .same(proto: "name"),
    9: .same(proto: "ownership"),
    10: .same(proto: "type"),
    11: .same(proto: "images"),
    12: .same(proto: "closed"),
    13: .same(proto: "identifiers"),
    14: .same(proto: "exclusionType"),
    15: .same(proto: "flags"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _balance: CurrencyDenominatedAmount? = nil
    var _accountNumber: String = String()
    var _credentialID: String = String()
    var _excluded: Bool = false
    var _favored: Bool = false
    var _transactional: Bool = false
    var _name: String = String()
    var _ownership: ExactNumber? = nil
    var _type: Account.TypeEnum = .unknown
    var _images: Images? = nil
    var _closed: Bool = false
    var _identifiers: [String] = []
    var _exclusionType: Account.Exclusion = .unkown
    var _flags: [Account.AccountFlag] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _balance = source._balance
      _accountNumber = source._accountNumber
      _credentialID = source._credentialID
      _excluded = source._excluded
      _favored = source._favored
      _transactional = source._transactional
      _name = source._name
      _ownership = source._ownership
      _type = source._type
      _images = source._images
      _closed = source._closed
      _identifiers = source._identifiers
      _exclusionType = source._exclusionType
      _flags = source._flags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 3: try decoder.decodeSingularStringField(value: &_storage._accountNumber)
        case 4: try decoder.decodeSingularStringField(value: &_storage._credentialID)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._excluded)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._favored)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._transactional)
        case 8: try decoder.decodeSingularStringField(value: &_storage._name)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._ownership)
        case 10: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._images)
        case 12: try decoder.decodeSingularBoolField(value: &_storage._closed)
        case 13: try decoder.decodeRepeatedStringField(value: &_storage._identifiers)
        case 14: try decoder.decodeSingularEnumField(value: &_storage._exclusionType)
        case 15: try decoder.decodeRepeatedEnumField(value: &_storage._flags)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._accountNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountNumber, fieldNumber: 3)
      }
      if !_storage._credentialID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._credentialID, fieldNumber: 4)
      }
      if _storage._excluded != false {
        try visitor.visitSingularBoolField(value: _storage._excluded, fieldNumber: 5)
      }
      if _storage._favored != false {
        try visitor.visitSingularBoolField(value: _storage._favored, fieldNumber: 6)
      }
      if _storage._transactional != false {
        try visitor.visitSingularBoolField(value: _storage._transactional, fieldNumber: 7)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 8)
      }
      if let v = _storage._ownership {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 10)
      }
      if let v = _storage._images {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._closed != false {
        try visitor.visitSingularBoolField(value: _storage._closed, fieldNumber: 12)
      }
      if !_storage._identifiers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._identifiers, fieldNumber: 13)
      }
      if _storage._exclusionType != .unkown {
        try visitor.visitSingularEnumField(value: _storage._exclusionType, fieldNumber: 14)
      }
      if !_storage._flags.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._flags, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Account, rhs: Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._accountNumber != rhs_storage._accountNumber {return false}
        if _storage._credentialID != rhs_storage._credentialID {return false}
        if _storage._excluded != rhs_storage._excluded {return false}
        if _storage._favored != rhs_storage._favored {return false}
        if _storage._transactional != rhs_storage._transactional {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._ownership != rhs_storage._ownership {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._closed != rhs_storage._closed {return false}
        if _storage._identifiers != rhs_storage._identifiers {return false}
        if _storage._exclusionType != rhs_storage._exclusionType {return false}
        if _storage._flags != rhs_storage._flags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_CHECKING"),
    2: .same(proto: "TYPE_SAVINGS"),
    3: .same(proto: "TYPE_INVESTMENT"),
    4: .same(proto: "TYPE_MORTGAGE"),
    5: .same(proto: "TYPE_CREDIT_CARD"),
    6: .same(proto: "TYPE_LOAN"),
    7: .same(proto: "TYPE_DUMMY"),
    8: .same(proto: "TYPE_PENSION"),
    9: .same(proto: "TYPE_OTHER"),
    10: .same(proto: "TYPE_EXTERNAL"),
  ]
}

extension Account.Exclusion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKOWN"),
    1: .same(proto: "PFM_AND_SEARCH"),
    2: .same(proto: "PFM_DATA"),
    3: .same(proto: "NONE"),
    4: .same(proto: "AGGREGATION"),
  ]
}

extension Account.AccountFlag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BUSINESS"),
    2: .same(proto: "MANDATE"),
  ]
}

extension Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Tag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tag, rhs: Tag) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "amount"),
    3: .standard(proto: "category_code"),
    4: .standard(proto: "original_amount"),
    5: .same(proto: "date"),
    6: .same(proto: "description"),
    7: .same(proto: "id"),
    8: .same(proto: "notes"),
    15: .same(proto: "tags"),
    9: .standard(proto: "original_date"),
    10: .standard(proto: "original_description"),
    11: .same(proto: "details"),
    12: .same(proto: "pending"),
    13: .same(proto: "upcoming"),
    14: .same(proto: "type"),
    16: .standard(proto: "secondary_description"),
    17: .same(proto: "inserted"),
    18: .same(proto: "parts"),
    19: .standard(proto: "dispensable_amount"),
  ]

  fileprivate class _StorageClass {
    var _accountID: String = String()
    var _amount: CurrencyDenominatedAmount? = nil
    var _categoryCode: String = String()
    var _originalAmount: CurrencyDenominatedAmount? = nil
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _id: String = String()
    var _notes: String = String()
    var _tags: [Tag] = []
    var _originalDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _originalDescription: String = String()
    var _details: Transaction.TransactionDetails? = nil
    var _pending: Bool = false
    var _upcoming: Bool = false
    var _type: Transaction.TypeEnum = .unknown
    var _secondaryDescription: String = String()
    var _inserted: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _parts: [Transaction.Part] = []
    var _dispensableAmount: CurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _amount = source._amount
      _categoryCode = source._categoryCode
      _originalAmount = source._originalAmount
      _date = source._date
      _description_p = source._description_p
      _id = source._id
      _notes = source._notes
      _tags = source._tags
      _originalDate = source._originalDate
      _originalDescription = source._originalDescription
      _details = source._details
      _pending = source._pending
      _upcoming = source._upcoming
      _type = source._type
      _secondaryDescription = source._secondaryDescription
      _inserted = source._inserted
      _parts = source._parts
      _dispensableAmount = source._dispensableAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._accountID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 3: try decoder.decodeSingularStringField(value: &_storage._categoryCode)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._originalAmount)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 6: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 7: try decoder.decodeSingularStringField(value: &_storage._id)
        case 8: try decoder.decodeSingularStringField(value: &_storage._notes)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._originalDate)
        case 10: try decoder.decodeSingularStringField(value: &_storage._originalDescription)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._details)
        case 12: try decoder.decodeSingularBoolField(value: &_storage._pending)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._upcoming)
        case 14: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 15: try decoder.decodeRepeatedMessageField(value: &_storage._tags)
        case 16: try decoder.decodeSingularStringField(value: &_storage._secondaryDescription)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._inserted)
        case 18: try decoder.decodeRepeatedMessageField(value: &_storage._parts)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._dispensableAmount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 1)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._categoryCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._categoryCode, fieldNumber: 3)
      }
      if let v = _storage._originalAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 6)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 7)
      }
      if !_storage._notes.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notes, fieldNumber: 8)
      }
      if let v = _storage._originalDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._originalDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._originalDescription, fieldNumber: 10)
      }
      if let v = _storage._details {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._pending != false {
        try visitor.visitSingularBoolField(value: _storage._pending, fieldNumber: 12)
      }
      if _storage._upcoming != false {
        try visitor.visitSingularBoolField(value: _storage._upcoming, fieldNumber: 13)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 14)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 15)
      }
      if !_storage._secondaryDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._secondaryDescription, fieldNumber: 16)
      }
      if let v = _storage._inserted {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if !_storage._parts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._parts, fieldNumber: 18)
      }
      if let v = _storage._dispensableAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Transaction, rhs: Transaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._categoryCode != rhs_storage._categoryCode {return false}
        if _storage._originalAmount != rhs_storage._originalAmount {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._notes != rhs_storage._notes {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._originalDate != rhs_storage._originalDate {return false}
        if _storage._originalDescription != rhs_storage._originalDescription {return false}
        if _storage._details != rhs_storage._details {return false}
        if _storage._pending != rhs_storage._pending {return false}
        if _storage._upcoming != rhs_storage._upcoming {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._secondaryDescription != rhs_storage._secondaryDescription {return false}
        if _storage._inserted != rhs_storage._inserted {return false}
        if _storage._parts != rhs_storage._parts {return false}
        if _storage._dispensableAmount != rhs_storage._dispensableAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_DEFAULT"),
    2: .same(proto: "TYPE_CREDIT_CARD"),
    3: .same(proto: "TYPE_PAYMENT"),
    4: .same(proto: "TYPE_TRANSFER"),
    5: .same(proto: "TYPE_WITHDRAWAL"),
  ]
}

extension Transaction.TransactionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Transaction.protoMessageName + ".TransactionDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transfer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.transferID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transferID.isEmpty {
      try visitor.visitSingularStringField(value: self.transferID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Transaction.TransactionDetails, rhs: Transaction.TransactionDetails) -> Bool {
    if lhs.transferID != rhs.transferID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction.Part: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Transaction.protoMessageName + ".Part"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "amount"),
    3: .standard(proto: "category_code"),
    4: .same(proto: "counterpart"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _amount: CurrencyDenominatedAmount? = nil
    var _categoryCode: String = String()
    var _counterpart: Transaction.Counterpart? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _amount = source._amount
      _categoryCode = source._categoryCode
      _counterpart = source._counterpart
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 3: try decoder.decodeSingularStringField(value: &_storage._categoryCode)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._counterpart)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._categoryCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._categoryCode, fieldNumber: 3)
      }
      if let v = _storage._counterpart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Transaction.Part, rhs: Transaction.Part) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._categoryCode != rhs_storage._categoryCode {return false}
        if _storage._counterpart != rhs_storage._counterpart {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction.Counterpart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Transaction.protoMessageName + ".Counterpart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "transaction_id"),
    3: .standard(proto: "transaction_amount"),
    4: .standard(proto: "transaction_description"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _transactionID: String = String()
    var _transactionAmount: CurrencyDenominatedAmount? = nil
    var _transactionDescription: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _transactionID = source._transactionID
      _transactionAmount = source._transactionAmount
      _transactionDescription = source._transactionDescription
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._transactionID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._transactionAmount)
        case 4: try decoder.decodeSingularStringField(value: &_storage._transactionDescription)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._transactionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transactionID, fieldNumber: 2)
      }
      if let v = _storage._transactionAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._transactionDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transactionDescription, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Transaction.Counterpart, rhs: Transaction.Counterpart) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._transactionAmount != rhs_storage._transactionAmount {return false}
        if _storage._transactionDescription != rhs_storage._transactionDescription {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Provider"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "type"),
    4: .same(proto: "status"),
    5: .standard(proto: "credential_type"),
    6: .standard(proto: "help_text"),
    7: .same(proto: "popular"),
    8: .same(proto: "fields"),
    9: .standard(proto: "group_display_name"),
    10: .same(proto: "images"),
    11: .standard(proto: "display_description"),
    12: .same(proto: "capabilities"),
    13: .standard(proto: "market_code"),
    14: .standard(proto: "access_type"),
    17: .standard(proto: "financial_institution_id"),
    18: .standard(proto: "financial_institution_name"),
    19: .standard(proto: "authentication_flow"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _type: Provider.TypeEnum = .unknown
    var _status: Provider.Status = .unknown
    var _credentialType: Credential.TypeEnum = .unknown
    var _helpText: String = String()
    var _popular: Bool = false
    var _fields: [ProviderFieldSpecification] = []
    var _groupDisplayName: String = String()
    var _images: Images? = nil
    var _displayDescription: String = String()
    var _capabilities: [Provider.Capability] = []
    var _marketCode: String = String()
    var _accessType: Provider.AccessType = .unknown
    var _financialInstitutionID: String = String()
    var _financialInstitutionName: String = String()
    var _authenticationFlow: Provider.AuthenticationFlow = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _type = source._type
      _status = source._status
      _credentialType = source._credentialType
      _helpText = source._helpText
      _popular = source._popular
      _fields = source._fields
      _groupDisplayName = source._groupDisplayName
      _images = source._images
      _displayDescription = source._displayDescription
      _capabilities = source._capabilities
      _marketCode = source._marketCode
      _accessType = source._accessType
      _financialInstitutionID = source._financialInstitutionID
      _financialInstitutionName = source._financialInstitutionName
      _authenticationFlow = source._authenticationFlow
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._displayName)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._credentialType)
        case 6: try decoder.decodeSingularStringField(value: &_storage._helpText)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._popular)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._fields)
        case 9: try decoder.decodeSingularStringField(value: &_storage._groupDisplayName)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._images)
        case 11: try decoder.decodeSingularStringField(value: &_storage._displayDescription)
        case 12: try decoder.decodeRepeatedEnumField(value: &_storage._capabilities)
        case 13: try decoder.decodeSingularStringField(value: &_storage._marketCode)
        case 14: try decoder.decodeSingularEnumField(value: &_storage._accessType)
        case 17: try decoder.decodeSingularStringField(value: &_storage._financialInstitutionID)
        case 18: try decoder.decodeSingularStringField(value: &_storage._financialInstitutionName)
        case 19: try decoder.decodeSingularEnumField(value: &_storage._authenticationFlow)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      if _storage._status != .unknown {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 4)
      }
      if _storage._credentialType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._credentialType, fieldNumber: 5)
      }
      if !_storage._helpText.isEmpty {
        try visitor.visitSingularStringField(value: _storage._helpText, fieldNumber: 6)
      }
      if _storage._popular != false {
        try visitor.visitSingularBoolField(value: _storage._popular, fieldNumber: 7)
      }
      if !_storage._fields.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._fields, fieldNumber: 8)
      }
      if !_storage._groupDisplayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupDisplayName, fieldNumber: 9)
      }
      if let v = _storage._images {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._displayDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayDescription, fieldNumber: 11)
      }
      if !_storage._capabilities.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._capabilities, fieldNumber: 12)
      }
      if !_storage._marketCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._marketCode, fieldNumber: 13)
      }
      if _storage._accessType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._accessType, fieldNumber: 14)
      }
      if !_storage._financialInstitutionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._financialInstitutionID, fieldNumber: 17)
      }
      if !_storage._financialInstitutionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._financialInstitutionName, fieldNumber: 18)
      }
      if _storage._authenticationFlow != .unknown {
        try visitor.visitSingularEnumField(value: _storage._authenticationFlow, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provider, rhs: Provider) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._credentialType != rhs_storage._credentialType {return false}
        if _storage._helpText != rhs_storage._helpText {return false}
        if _storage._popular != rhs_storage._popular {return false}
        if _storage._fields != rhs_storage._fields {return false}
        if _storage._groupDisplayName != rhs_storage._groupDisplayName {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._displayDescription != rhs_storage._displayDescription {return false}
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._marketCode != rhs_storage._marketCode {return false}
        if _storage._accessType != rhs_storage._accessType {return false}
        if _storage._financialInstitutionID != rhs_storage._financialInstitutionID {return false}
        if _storage._financialInstitutionName != rhs_storage._financialInstitutionName {return false}
        if _storage._authenticationFlow != rhs_storage._authenticationFlow {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provider.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_BANK"),
    2: .same(proto: "TYPE_CREDIT_CARD"),
    3: .same(proto: "TYPE_BROKER"),
    4: .same(proto: "TYPE_OTHER"),
    5: .same(proto: "TYPE_TEST"),
    6: .same(proto: "TYPE_FRAUD"),
  ]
}

extension Provider.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_ENABLED"),
    2: .same(proto: "STATUS_DISABLED"),
    3: .same(proto: "STATUS_TEMPORARY_DISABLED"),
    4: .same(proto: "STATUS_OBSOLETE"),
  ]
}

extension Provider.Capability: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CAPABILITY_UNKNOWN"),
    1: .same(proto: "CAPABILITY_TRANSFERS"),
    2: .same(proto: "CAPABILITY_MORTGAGE_AGGREGATION"),
    3: .same(proto: "CAPABILITY_CHECKING_ACCOUNTS"),
    4: .same(proto: "CAPABILITY_SAVINGS_ACCOUNTS"),
    5: .same(proto: "CAPABILITY_CREDIT_CARDS"),
    6: .same(proto: "CAPABILITY_INVESTMENTS"),
    7: .same(proto: "CAPABILITY_LOANS"),
    8: .same(proto: "CAPABILITY_PAYMENTS"),
    9: .same(proto: "CAPABILITY_MORTGAGE_LOAN"),
    10: .same(proto: "CAPABILITY_IDENTITY_DATA"),
  ]
}

extension Provider.AccessType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCESS_TYPE_UNKNOWN"),
    1: .same(proto: "ACCESS_TYPE_OPEN_BANKING"),
    2: .same(proto: "ACCESS_TYPE_OTHER"),
  ]
}

extension Provider.AuthenticationFlow: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATION_FLOW_UNKNOWN"),
    1: .same(proto: "AUTHENTICATION_FLOW_EMBEDDED"),
    2: .same(proto: "AUTHENTICATION_FLOW_REDIRECT"),
    3: .same(proto: "AUTHENTICATION_FLOW_DECOUPLED"),
  ]
}

extension CurrencyDenominatedAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CurrencyDenominatedAmount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "currency_code"),
  ]

  fileprivate class _StorageClass {
    var _value: ExactNumber? = nil
    var _currencyCode: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _currencyCode = source._currencyCode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 2: try decoder.decodeSingularStringField(value: &_storage._currencyCode)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._currencyCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currencyCode, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CurrencyDenominatedAmount, rhs: CurrencyDenominatedAmount) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._currencyCode != rhs_storage._currencyCode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExactNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ExactNumber"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unscaledValue"),
    2: .same(proto: "scale"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.unscaledValue)
      case 2: try decoder.decodeSingularInt64Field(value: &self.scale)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unscaledValue != 0 {
      try visitor.visitSingularInt64Field(value: self.unscaledValue, fieldNumber: 1)
    }
    if self.scale != 0 {
      try visitor.visitSingularInt64Field(value: self.scale, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ExactNumber, rhs: ExactNumber) -> Bool {
    if lhs.unscaledValue != rhs.unscaledValue {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Period: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Period"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "week"),
    4: .same(proto: "day"),
    5: .same(proto: "start"),
    6: .same(proto: "stop"),
  ]

  fileprivate class _StorageClass {
    var _year: UInt32 = 0
    var _month: UInt32 = 0
    var _week: UInt32 = 0
    var _day: UInt32 = 0
    var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _stop: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _year = source._year
      _month = source._month
      _week = source._week
      _day = source._day
      _start = source._start
      _stop = source._stop
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._year)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._month)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._week)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._day)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._start)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._stop)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._year != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._year, fieldNumber: 1)
      }
      if _storage._month != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._month, fieldNumber: 2)
      }
      if _storage._week != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._week, fieldNumber: 3)
      }
      if _storage._day != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._day, fieldNumber: 4)
      }
      if let v = _storage._start {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._stop {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Period, rhs: Period) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._year != rhs_storage._year {return false}
        if _storage._month != rhs_storage._month {return false}
        if _storage._week != rhs_storage._week {return false}
        if _storage._day != rhs_storage._day {return false}
        if _storage._start != rhs_storage._start {return false}
        if _storage._stop != rhs_storage._stop {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeriodDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PeriodDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "week"),
    4: .same(proto: "day"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.year)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.month)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.week)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.day)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.week != 0 {
      try visitor.visitSingularUInt32Field(value: self.week, fieldNumber: 3)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PeriodDescription, rhs: PeriodDescription) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.week != rhs.week {return false}
    if lhs.day != rhs.day {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StatisticTree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StatisticTree"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "balances_by_account_id"),
    2: .standard(proto: "balances_by_account_group_type"),
    3: .standard(proto: "left_to_spend"),
    5: .standard(proto: "expenses_by_category_code"),
    6: .standard(proto: "income_by_category_code"),
    7: .standard(proto: "loan_rates_by_property"),
    8: .standard(proto: "loan_balances_by_property"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: &self.balancesByAccountID)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: &self.balancesByAccountGroupType)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: &self.leftToSpend)
      case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: &self.expensesByCategoryCode)
      case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: &self.incomeByCategoryCode)
      case 7: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: &self.loanRatesByProperty)
      case 8: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: &self.loanBalancesByProperty)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.balancesByAccountID.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: self.balancesByAccountID, fieldNumber: 1)
    }
    if !self.balancesByAccountGroupType.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: self.balancesByAccountGroupType, fieldNumber: 2)
    }
    if !self.leftToSpend.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: self.leftToSpend, fieldNumber: 3)
    }
    if !self.expensesByCategoryCode.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: self.expensesByCategoryCode, fieldNumber: 5)
    }
    if !self.incomeByCategoryCode.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: self.incomeByCategoryCode, fieldNumber: 6)
    }
    if !self.loanRatesByProperty.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: self.loanRatesByProperty, fieldNumber: 7)
    }
    if !self.loanBalancesByProperty.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: self.loanBalancesByProperty, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StatisticTree, rhs: StatisticTree) -> Bool {
    if lhs.balancesByAccountID != rhs.balancesByAccountID {return false}
    if lhs.balancesByAccountGroupType != rhs.balancesByAccountGroupType {return false}
    if lhs.leftToSpend != rhs.leftToSpend {return false}
    if lhs.expensesByCategoryCode != rhs.expensesByCategoryCode {return false}
    if lhs.incomeByCategoryCode != rhs.incomeByCategoryCode {return false}
    if lhs.loanRatesByProperty != rhs.loanRatesByProperty {return false}
    if lhs.loanBalancesByProperty != rhs.loanBalancesByProperty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StatisticTree.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_BALANCES_BY_ACCOUNT_ID"),
    2: .same(proto: "TYPE_BALANCES_BY_ACCOUNT_GROUP_TYPE"),
    3: .same(proto: "TYPE_LEFT_TO_SPEND"),
    4: .same(proto: "TYPE_EXPENCES_BY_CATEGORY_CODE"),
    5: .same(proto: "TYPE_INCOME_BY_CATEGORY_CODE"),
  ]
}

extension StatisticNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StatisticNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "period"),
    2: .same(proto: "amount"),
    4: .same(proto: "value"),
    3: .same(proto: "children"),
  ]

  fileprivate class _StorageClass {
    var _period: Period? = nil
    var _nodeValue: StatisticNode.OneOf_NodeValue?
    var _children: Dictionary<String,StatisticNode> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _period = source._period
      _nodeValue = source._nodeValue
      _children = source._children
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._period)
        case 2:
          var v: CurrencyDenominatedAmount?
          if let current = _storage._nodeValue {
            try decoder.handleConflictingOneOf()
            if case .amount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nodeValue = .amount(v)}
        case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: &_storage._children)
        case 4:
          var v: ExactNumber?
          if let current = _storage._nodeValue {
            try decoder.handleConflictingOneOf()
            if case .value(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nodeValue = .value(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._period {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if case .amount(let v)? = _storage._nodeValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._children.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StatisticNode>.self, value: _storage._children, fieldNumber: 3)
      }
      if case .value(let v)? = _storage._nodeValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StatisticNode, rhs: StatisticNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._period != rhs_storage._period {return false}
        if _storage._nodeValue != rhs_storage._nodeValue {return false}
        if _storage._children != rhs_storage._children {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FollowItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FollowItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expenses_criteria"),
    2: .standard(proto: "search_criteria"),
    3: .standard(proto: "saving_criteria"),
    4: .same(proto: "data"),
    5: .same(proto: "id"),
    6: .same(proto: "name"),
    7: .standard(proto: "created_date"),
  ]

  fileprivate class _StorageClass {
    var _criteria: FollowItem.OneOf_Criteria?
    var _data: FollowData? = nil
    var _id: String = String()
    var _name: String = String()
    var _createdDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _criteria = source._criteria
      _data = source._data
      _id = source._id
      _name = source._name
      _createdDate = source._createdDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: ExpensesFollowCriteria?
          if let current = _storage._criteria {
            try decoder.handleConflictingOneOf()
            if case .expensesCriteria(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._criteria = .expensesCriteria(v)}
        case 2:
          var v: SearchFollowCriteria?
          if let current = _storage._criteria {
            try decoder.handleConflictingOneOf()
            if case .searchCriteria(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._criteria = .searchCriteria(v)}
        case 3:
          var v: SavingsFollowCriteria?
          if let current = _storage._criteria {
            try decoder.handleConflictingOneOf()
            if case .savingCriteria(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._criteria = .savingCriteria(v)}
        case 4: try decoder.decodeSingularMessageField(value: &_storage._data)
        case 5: try decoder.decodeSingularStringField(value: &_storage._id)
        case 6: try decoder.decodeSingularStringField(value: &_storage._name)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._createdDate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._criteria {
      case .expensesCriteria(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .searchCriteria(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .savingCriteria(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 5)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 6)
      }
      if let v = _storage._createdDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FollowItem, rhs: FollowItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._criteria != rhs_storage._criteria {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._createdDate != rhs_storage._createdDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FollowItemHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FollowItemHistory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "historical_amounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.historicalAmounts)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.historicalAmounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.historicalAmounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FollowItemHistory, rhs: FollowItemHistory) -> Bool {
    if lhs.historicalAmounts != rhs.historicalAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExpensesFollowCriteria: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ExpensesFollowCriteria"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_amount"),
    2: .standard(proto: "category_codes"),
  ]

  fileprivate class _StorageClass {
    var _targetAmount: ExactNumber? = nil
    var _categoryCodes: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetAmount = source._targetAmount
      _categoryCodes = source._categoryCodes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._targetAmount)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._categoryCodes)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._targetAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._categoryCodes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._categoryCodes, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ExpensesFollowCriteria, rhs: ExpensesFollowCriteria) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetAmount != rhs_storage._targetAmount {return false}
        if _storage._categoryCodes != rhs_storage._categoryCodes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SearchFollowCriteria: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SearchFollowCriteria"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_amount"),
    2: .same(proto: "query"),
  ]

  fileprivate class _StorageClass {
    var _targetAmount: ExactNumber? = nil
    var _query: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetAmount = source._targetAmount
      _query = source._query
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._targetAmount)
        case 2: try decoder.decodeSingularStringField(value: &_storage._query)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._targetAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SearchFollowCriteria, rhs: SearchFollowCriteria) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetAmount != rhs_storage._targetAmount {return false}
        if _storage._query != rhs_storage._query {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SavingsFollowCriteria: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SavingsFollowCriteria"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_amount"),
    2: .standard(proto: "account_ids"),
    3: .same(proto: "period"),
  ]

  fileprivate class _StorageClass {
    var _targetAmount: ExactNumber? = nil
    var _accountIds: [String] = []
    var _period: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetAmount = source._targetAmount
      _accountIds = source._accountIds
      _period = source._period
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._targetAmount)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._accountIds)
        case 3: try decoder.decodeSingularStringField(value: &_storage._period)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._targetAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._accountIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._accountIds, fieldNumber: 2)
      }
      if !_storage._period.isEmpty {
        try visitor.visitSingularStringField(value: _storage._period, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SavingsFollowCriteria, rhs: SavingsFollowCriteria) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetAmount != rhs_storage._targetAmount {return false}
        if _storage._accountIds != rhs_storage._accountIds {return false}
        if _storage._period != rhs_storage._period {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FollowData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FollowData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "historical_amounts"),
    2: .same(proto: "period"),
  ]

  fileprivate class _StorageClass {
    var _historicalAmounts: [PeriodExactNumberPair] = []
    var _period: Period? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _historicalAmounts = source._historicalAmounts
      _period = source._period
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._historicalAmounts)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._period)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._historicalAmounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._historicalAmounts, fieldNumber: 1)
      }
      if let v = _storage._period {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FollowData, rhs: FollowData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._historicalAmounts != rhs_storage._historicalAmounts {return false}
        if _storage._period != rhs_storage._period {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeriodExactNumberPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PeriodExactNumberPair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "period"),
    2: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _period: Period? = nil
    var _value: ExactNumber? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _period = source._period
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._period)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._value)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._period {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PeriodExactNumberPair, rhs: PeriodExactNumberPair) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._period != rhs_storage._period {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Budget"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget, rhs: Budget) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.Specification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.protoMessageName + ".Specification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "amount"),
    5: .standard(proto: "recurring_periodicity"),
    6: .standard(proto: "one_off_periodicity"),
    7: .same(proto: "archived"),
    8: .same(proto: "filter"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _amount: CurrencyDenominatedAmount? = nil
    var _periodicity: Budget.Specification.OneOf_Periodicity?
    var _archived: Bool = false
    var _filter: Budget.Filter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _description_p = source._description_p
      _amount = source._amount
      _periodicity = source._periodicity
      _archived = source._archived
      _filter = source._filter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 5:
          var v: Budget.RecurringPeriodicity?
          if let current = _storage._periodicity {
            try decoder.handleConflictingOneOf()
            if case .recurringPeriodicity(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._periodicity = .recurringPeriodicity(v)}
        case 6:
          var v: Budget.OneOffPeriodicity?
          if let current = _storage._periodicity {
            try decoder.handleConflictingOneOf()
            if case .oneOffPeriodicity(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._periodicity = .oneOffPeriodicity(v)}
        case 7: try decoder.decodeSingularBoolField(value: &_storage._archived)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._filter)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      switch _storage._periodicity {
      case .recurringPeriodicity(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .oneOffPeriodicity(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
      if _storage._archived != false {
        try visitor.visitSingularBoolField(value: _storage._archived, fieldNumber: 7)
      }
      if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.Specification, rhs: Budget.Specification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._periodicity != rhs_storage._periodicity {return false}
        if _storage._archived != rhs_storage._archived {return false}
        if _storage._filter != rhs_storage._filter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
    2: .same(proto: "categories"),
    3: .same(proto: "tags"),
    4: .standard(proto: "free_text_query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.accounts)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.categories)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.tags)
      case 4: try decoder.decodeSingularStringField(value: &self.freeTextQuery)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    if !self.categories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categories, fieldNumber: 2)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 3)
    }
    if !self.freeTextQuery.isEmpty {
      try visitor.visitSingularStringField(value: self.freeTextQuery, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.Filter, rhs: Budget.Filter) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.freeTextQuery != rhs.freeTextQuery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.Filter.Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.Filter.protoMessageName + ".Account"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.Filter.Account, rhs: Budget.Filter.Account) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.Filter.Category: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.Filter.protoMessageName + ".Category"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.Filter.Category, rhs: Budget.Filter.Category) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.Filter.Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.Filter.protoMessageName + ".Tag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.Filter.Tag, rhs: Budget.Filter.Tag) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.OneOffPeriodicity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.protoMessageName + ".OneOffPeriodicity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  fileprivate class _StorageClass {
    var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _start = source._start
      _end = source._end
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._start)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._end)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._start {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._end {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.OneOffPeriodicity, rhs: Budget.OneOffPeriodicity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._start != rhs_storage._start {return false}
        if _storage._end != rhs_storage._end {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.RecurringPeriodicity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.protoMessageName + ".RecurringPeriodicity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "period_unit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.periodUnit)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.periodUnit != .unknown {
      try visitor.visitSingularEnumField(value: self.periodUnit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.RecurringPeriodicity, rhs: Budget.RecurringPeriodicity) -> Bool {
    if lhs.periodUnit != rhs.periodUnit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.RecurringPeriodicity.PeriodUnit: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERIOD_UNIT_UNKNOWN"),
    1: .same(proto: "PERIOD_UNIT_WEEK"),
    2: .same(proto: "PERIOD_UNIT_MONTH"),
    3: .same(proto: "PERIOD_UNIT_YEAR"),
  ]
}

extension Budget.Period: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.protoMessageName + ".Period"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .standard(proto: "spent_amount"),
    4: .standard(proto: "budget_amount"),
  ]

  fileprivate class _StorageClass {
    var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _spentAmount: CurrencyDenominatedAmount? = nil
    var _budgetAmount: CurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _start = source._start
      _end = source._end
      _spentAmount = source._spentAmount
      _budgetAmount = source._budgetAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._start)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._end)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._spentAmount)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._budgetAmount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._start {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._end {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._spentAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._budgetAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.Period, rhs: Budget.Period) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._start != rhs_storage._start {return false}
        if _storage._end != rhs_storage._end {return false}
        if _storage._spentAmount != rhs_storage._spentAmount {return false}
        if _storage._budgetAmount != rhs_storage._budgetAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.Summary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.protoMessageName + ".Summary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "budget_specification"),
    2: .standard(proto: "current_budget_period"),
  ]

  fileprivate class _StorageClass {
    var _budgetSpecification: Budget.Specification? = nil
    var _currentBudgetPeriod: Budget.Period? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _budgetSpecification = source._budgetSpecification
      _currentBudgetPeriod = source._currentBudgetPeriod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._budgetSpecification)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._currentBudgetPeriod)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._budgetSpecification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._currentBudgetPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.Summary, rhs: Budget.Summary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._budgetSpecification != rhs_storage._budgetSpecification {return false}
        if _storage._currentBudgetPeriod != rhs_storage._currentBudgetPeriod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Budget.Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Budget.protoMessageName + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "amount"),
    3: .standard(proto: "dispensable_amount"),
    4: .same(proto: "date"),
    5: .same(proto: "description"),
    6: .standard(proto: "category_code"),
    7: .standard(proto: "account_id"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _amount: CurrencyDenominatedAmount? = nil
    var _dispensableAmount: CurrencyDenominatedAmount? = nil
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _categoryCode: String = String()
    var _accountID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _amount = source._amount
      _dispensableAmount = source._dispensableAmount
      _date = source._date
      _description_p = source._description_p
      _categoryCode = source._categoryCode
      _accountID = source._accountID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._dispensableAmount)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 5: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 6: try decoder.decodeSingularStringField(value: &_storage._categoryCode)
        case 7: try decoder.decodeSingularStringField(value: &_storage._accountID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._dispensableAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 5)
      }
      if !_storage._categoryCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._categoryCode, fieldNumber: 6)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Budget.Transaction, rhs: Budget.Transaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._dispensableAmount != rhs_storage._dispensableAmount {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._categoryCode != rhs_storage._categoryCode {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Currency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Currency"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "factor"),
    3: .same(proto: "prefixed"),
    4: .same(proto: "symbol"),
  ]

  fileprivate class _StorageClass {
    var _code: String = String()
    var _factor: ExactNumber? = nil
    var _prefixed: Bool = false
    var _symbol: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _factor = source._factor
      _prefixed = source._prefixed
      _symbol = source._symbol
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._factor)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._prefixed)
        case 4: try decoder.decodeSingularStringField(value: &_storage._symbol)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._code.isEmpty {
        try visitor.visitSingularStringField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._factor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._prefixed != false {
        try visitor.visitSingularBoolField(value: _storage._prefixed, fieldNumber: 3)
      }
      if !_storage._symbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbol, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Currency, rhs: Currency) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._factor != rhs_storage._factor {return false}
        if _storage._prefixed != rhs_storage._prefixed {return false}
        if _storage._symbol != rhs_storage._symbol {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Loan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Loan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "interest"),
    3: .standard(proto: "number_of_months_bound"),
    4: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _accountID: String = String()
    var _interest: ExactNumber? = nil
    var _numberOfMonthsBound: Int32 = 0
    var _type: Loan.TypeEnum = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _interest = source._interest
      _numberOfMonthsBound = source._numberOfMonthsBound
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._accountID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._interest)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._numberOfMonthsBound)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._type)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 1)
      }
      if let v = _storage._interest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._numberOfMonthsBound != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numberOfMonthsBound, fieldNumber: 3)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Loan, rhs: Loan) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._interest != rhs_storage._interest {return false}
        if _storage._numberOfMonthsBound != rhs_storage._numberOfMonthsBound {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Loan.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_MORTGAGE"),
    2: .same(proto: "TYPE_BLANCO"),
    3: .same(proto: "TYPE_MEMBERSHIP"),
    4: .same(proto: "TYPE_VEHICLE"),
    5: .same(proto: "TYPE_LAND"),
    6: .same(proto: "TYPE_STUDENT"),
    7: .same(proto: "TYPE_OTHER"),
  ]
}

extension CategoryTree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CategoryTree"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expenses"),
    2: .same(proto: "income"),
    3: .same(proto: "transfers"),
  ]

  fileprivate class _StorageClass {
    var _expenses: CategoryNode? = nil
    var _income: CategoryNode? = nil
    var _transfers: CategoryNode? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _expenses = source._expenses
      _income = source._income
      _transfers = source._transfers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._expenses)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._income)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._transfers)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._expenses {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._income {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._transfers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CategoryTree, rhs: CategoryTree) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._expenses != rhs_storage._expenses {return false}
        if _storage._income != rhs_storage._income {return false}
        if _storage._transfers != rhs_storage._transfers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CategoryNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CategoryNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .same(proto: "children"),
    5: .standard(proto: "sort_order"),
    6: .standard(proto: "default_child"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.children)
      case 5: try decoder.decodeSingularInt32Field(value: &self.sortOrder)
      case 6: try decoder.decodeSingularBoolField(value: &self.defaultChild)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 4)
    }
    if self.sortOrder != 0 {
      try visitor.visitSingularInt32Field(value: self.sortOrder, fieldNumber: 5)
    }
    if self.defaultChild != false {
      try visitor.visitSingularBoolField(value: self.defaultChild, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CategoryNode, rhs: CategoryNode) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.children != rhs.children {return false}
    if lhs.sortOrder != rhs.sortOrder {return false}
    if lhs.defaultChild != rhs.defaultChild {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "notification_token"),
    3: .standard(proto: "notification_public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.notificationToken)
      case 3: try decoder.decodeSingularStringField(value: &self.notificationPublicKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.notificationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.notificationToken, fieldNumber: 2)
    }
    if !self.notificationPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.notificationPublicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Device, rhs: Device) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.notificationToken != rhs.notificationToken {return false}
    if lhs.notificationPublicKey != rhs.notificationPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceAppsFlyerOrigin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeviceAppsFlyerOrigin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "extra_param_1"),
    2: .standard(proto: "extra_param_2"),
    3: .standard(proto: "extra_param_3"),
    4: .standard(proto: "extra_param_4"),
    5: .standard(proto: "extra_param_5"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.extraParam1)
      case 2: try decoder.decodeSingularStringField(value: &self.extraParam2)
      case 3: try decoder.decodeSingularStringField(value: &self.extraParam3)
      case 4: try decoder.decodeSingularStringField(value: &self.extraParam4)
      case 5: try decoder.decodeSingularStringField(value: &self.extraParam5)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.extraParam1.isEmpty {
      try visitor.visitSingularStringField(value: self.extraParam1, fieldNumber: 1)
    }
    if !self.extraParam2.isEmpty {
      try visitor.visitSingularStringField(value: self.extraParam2, fieldNumber: 2)
    }
    if !self.extraParam3.isEmpty {
      try visitor.visitSingularStringField(value: self.extraParam3, fieldNumber: 3)
    }
    if !self.extraParam4.isEmpty {
      try visitor.visitSingularStringField(value: self.extraParam4, fieldNumber: 4)
    }
    if !self.extraParam5.isEmpty {
      try visitor.visitSingularStringField(value: self.extraParam5, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeviceAppsFlyerOrigin, rhs: DeviceAppsFlyerOrigin) -> Bool {
    if lhs.extraParam1 != rhs.extraParam1 {return false}
    if lhs.extraParam2 != rhs.extraParam2 {return false}
    if lhs.extraParam3 != rhs.extraParam3 {return false}
    if lhs.extraParam4 != rhs.extraParam4 {return false}
    if lhs.extraParam5 != rhs.extraParam5 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceFacebookOrigin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeviceFacebookOrigin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "campaign_id"),
    2: .standard(proto: "ad_group_id"),
    3: .standard(proto: "ad_group_name"),
    4: .standard(proto: "ad_set_id"),
    5: .standard(proto: "ad_set_name"),
    6: .standard(proto: "ad_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.campaignID)
      case 2: try decoder.decodeSingularStringField(value: &self.adGroupID)
      case 3: try decoder.decodeSingularStringField(value: &self.adGroupName)
      case 4: try decoder.decodeSingularStringField(value: &self.adSetID)
      case 5: try decoder.decodeSingularStringField(value: &self.adSetName)
      case 6: try decoder.decodeSingularStringField(value: &self.adID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.campaignID.isEmpty {
      try visitor.visitSingularStringField(value: self.campaignID, fieldNumber: 1)
    }
    if !self.adGroupID.isEmpty {
      try visitor.visitSingularStringField(value: self.adGroupID, fieldNumber: 2)
    }
    if !self.adGroupName.isEmpty {
      try visitor.visitSingularStringField(value: self.adGroupName, fieldNumber: 3)
    }
    if !self.adSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.adSetID, fieldNumber: 4)
    }
    if !self.adSetName.isEmpty {
      try visitor.visitSingularStringField(value: self.adSetName, fieldNumber: 5)
    }
    if !self.adID.isEmpty {
      try visitor.visitSingularStringField(value: self.adID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeviceFacebookOrigin, rhs: DeviceFacebookOrigin) -> Bool {
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.adGroupID != rhs.adGroupID {return false}
    if lhs.adGroupName != rhs.adGroupName {return false}
    if lhs.adSetID != rhs.adSetID {return false}
    if lhs.adSetName != rhs.adSetName {return false}
    if lhs.adID != rhs.adID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProviderFieldSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProviderFieldSpecification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "hint"),
    3: .standard(proto: "max_length"),
    4: .standard(proto: "min_length"),
    5: .same(proto: "masked"),
    6: .same(proto: "numeric"),
    7: .same(proto: "immutable"),
    8: .same(proto: "optional"),
    9: .same(proto: "name"),
    10: .same(proto: "value"),
    11: .same(proto: "pattern"),
    12: .standard(proto: "pattern_error"),
    13: .standard(proto: "help_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.description_p)
      case 2: try decoder.decodeSingularStringField(value: &self.hint)
      case 3: try decoder.decodeSingularInt32Field(value: &self.maxLength)
      case 4: try decoder.decodeSingularInt32Field(value: &self.minLength)
      case 5: try decoder.decodeSingularBoolField(value: &self.masked)
      case 6: try decoder.decodeSingularBoolField(value: &self.numeric)
      case 7: try decoder.decodeSingularBoolField(value: &self.immutable)
      case 8: try decoder.decodeSingularBoolField(value: &self.optional)
      case 9: try decoder.decodeSingularStringField(value: &self.name)
      case 10: try decoder.decodeSingularStringField(value: &self.value)
      case 11: try decoder.decodeSingularStringField(value: &self.pattern)
      case 12: try decoder.decodeSingularStringField(value: &self.patternError)
      case 13: try decoder.decodeSingularStringField(value: &self.helpText)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if !self.hint.isEmpty {
      try visitor.visitSingularStringField(value: self.hint, fieldNumber: 2)
    }
    if self.maxLength != 0 {
      try visitor.visitSingularInt32Field(value: self.maxLength, fieldNumber: 3)
    }
    if self.minLength != 0 {
      try visitor.visitSingularInt32Field(value: self.minLength, fieldNumber: 4)
    }
    if self.masked != false {
      try visitor.visitSingularBoolField(value: self.masked, fieldNumber: 5)
    }
    if self.numeric != false {
      try visitor.visitSingularBoolField(value: self.numeric, fieldNumber: 6)
    }
    if self.immutable != false {
      try visitor.visitSingularBoolField(value: self.immutable, fieldNumber: 7)
    }
    if self.optional != false {
      try visitor.visitSingularBoolField(value: self.optional, fieldNumber: 8)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 9)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 10)
    }
    if !self.pattern.isEmpty {
      try visitor.visitSingularStringField(value: self.pattern, fieldNumber: 11)
    }
    if !self.patternError.isEmpty {
      try visitor.visitSingularStringField(value: self.patternError, fieldNumber: 12)
    }
    if !self.helpText.isEmpty {
      try visitor.visitSingularStringField(value: self.helpText, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProviderFieldSpecification, rhs: ProviderFieldSpecification) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.hint != rhs.hint {return false}
    if lhs.maxLength != rhs.maxLength {return false}
    if lhs.minLength != rhs.minLength {return false}
    if lhs.masked != rhs.masked {return false}
    if lhs.numeric != rhs.numeric {return false}
    if lhs.immutable != rhs.immutable {return false}
    if lhs.optional != rhs.optional {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.pattern != rhs.pattern {return false}
    if lhs.patternError != rhs.patternError {return false}
    if lhs.helpText != rhs.helpText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GiroLookupEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GiroLookupEntity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .same(proto: "identifier"),
    3: .same(proto: "images"),
    4: .standard(proto: "display_number"),
  ]

  fileprivate class _StorageClass {
    var _displayName: String = String()
    var _identifier: String = String()
    var _images: Images? = nil
    var _displayNumber: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _displayName = source._displayName
      _identifier = source._identifier
      _images = source._images
      _displayNumber = source._displayNumber
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._displayName)
        case 2: try decoder.decodeSingularStringField(value: &_storage._identifier)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._images)
        case 4: try decoder.decodeSingularStringField(value: &_storage._displayNumber)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 1)
      }
      if !_storage._identifier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identifier, fieldNumber: 2)
      }
      if let v = _storage._images {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._displayNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayNumber, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GiroLookupEntity, rhs: GiroLookupEntity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._identifier != rhs_storage._identifier {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._displayNumber != rhs_storage._displayNumber {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Images: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Images"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "icon_url"),
    2: .standard(proto: "banner_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.iconURL)
      case 2: try decoder.decodeSingularStringField(value: &self.bannerURL)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 1)
    }
    if !self.bannerURL.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Images, rhs: Images) -> Bool {
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.bannerURL != rhs.bannerURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignableOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SignableOperation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "created"),
    2: .same(proto: "id"),
    3: .same(proto: "status"),
    4: .standard(proto: "status_message"),
    5: .same(proto: "type"),
    6: .standard(proto: "underlying_id"),
    7: .same(proto: "updated"),
    8: .standard(proto: "credential_id"),
    9: .standard(proto: "third_party_app_authentication"),
  ]

  fileprivate class _StorageClass {
    var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _id: String = String()
    var _status: SignableOperation.Status = .unknown
    var _statusMessage: String = String()
    var _type: SignableOperation.TypeEnum = .unknown
    var _underlyingID: String = String()
    var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _credentialID: String = String()
    var _thirdPartyAppAuthentication: ThirdPartyAppAuthentication? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _created = source._created
      _id = source._id
      _status = source._status
      _statusMessage = source._statusMessage
      _type = source._type
      _underlyingID = source._underlyingID
      _updated = source._updated
      _credentialID = source._credentialID
      _thirdPartyAppAuthentication = source._thirdPartyAppAuthentication
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._created)
        case 2: try decoder.decodeSingularStringField(value: &_storage._id)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 4: try decoder.decodeSingularStringField(value: &_storage._statusMessage)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 6: try decoder.decodeSingularStringField(value: &_storage._underlyingID)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._updated)
        case 8: try decoder.decodeSingularStringField(value: &_storage._credentialID)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._thirdPartyAppAuthentication)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      if _storage._status != .unknown {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 3)
      }
      if !_storage._statusMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusMessage, fieldNumber: 4)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 5)
      }
      if !_storage._underlyingID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._underlyingID, fieldNumber: 6)
      }
      if let v = _storage._updated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._credentialID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._credentialID, fieldNumber: 8)
      }
      if let v = _storage._thirdPartyAppAuthentication {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SignableOperation, rhs: SignableOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._created != rhs_storage._created {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusMessage != rhs_storage._statusMessage {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._underlyingID != rhs_storage._underlyingID {return false}
        if _storage._updated != rhs_storage._updated {return false}
        if _storage._credentialID != rhs_storage._credentialID {return false}
        if _storage._thirdPartyAppAuthentication != rhs_storage._thirdPartyAppAuthentication {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignableOperation.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "STATUS_CREATED"),
    2: .same(proto: "STATUS_EXECUTING"),
    3: .same(proto: "STATUS_AWAITING_CREDENTIALS"),
    4: .same(proto: "STATUS_CANCELLED"),
    5: .same(proto: "STATUS_FAILED"),
    6: .same(proto: "STATUS_EXECUTED"),
    7: .same(proto: "STATUS_AWAITING_THIRD_PARTY_APP_AUTHENTICATION"),
  ]
}

extension SignableOperation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_TRANSFER"),
    2: .same(proto: "TYPE_ACCOUNT_CREATE"),
    3: .same(proto: "TYPE_APPLICATION"),
  ]
}

extension TrackingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TrackingEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "category"),
    3: .same(proto: "action"),
    4: .same(proto: "label"),
    5: .standard(proto: "default_value"),
  ]

  fileprivate class _StorageClass {
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _category: String = String()
    var _action: String = String()
    var _label: String = String()
    var _defaultValue: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _date = source._date
      _category = source._category
      _action = source._action
      _label = source._label
      _defaultValue = source._defaultValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 2: try decoder.decodeSingularStringField(value: &_storage._category)
        case 3: try decoder.decodeSingularStringField(value: &_storage._action)
        case 4: try decoder.decodeSingularStringField(value: &_storage._label)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._defaultValue)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._category.isEmpty {
        try visitor.visitSingularStringField(value: _storage._category, fieldNumber: 2)
      }
      if !_storage._action.isEmpty {
        try visitor.visitSingularStringField(value: _storage._action, fieldNumber: 3)
      }
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 4)
      }
      if _storage._defaultValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._defaultValue, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TrackingEvent, rhs: TrackingEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._date != rhs_storage._date {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._defaultValue != rhs_storage._defaultValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TrackingTiming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TrackingTiming"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "category"),
    3: .same(proto: "time"),
    4: .same(proto: "label"),
    5: .same(proto: "name"),
  ]

  fileprivate class _StorageClass {
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _category: String = String()
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _label: String = String()
    var _name: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _date = source._date
      _category = source._category
      _time = source._time
      _label = source._label
      _name = source._name
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 2: try decoder.decodeSingularStringField(value: &_storage._category)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._time)
        case 4: try decoder.decodeSingularStringField(value: &_storage._label)
        case 5: try decoder.decodeSingularStringField(value: &_storage._name)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._category.isEmpty {
        try visitor.visitSingularStringField(value: _storage._category, fieldNumber: 2)
      }
      if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 4)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TrackingTiming, rhs: TrackingTiming) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._date != rhs_storage._date {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._name != rhs_storage._name {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TrackingView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TrackingView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "name"),
  ]

  fileprivate class _StorageClass {
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _name: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _date = source._date
      _name = source._name
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TrackingView, rhs: TrackingView) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._date != rhs_storage._date {return false}
        if _storage._name != rhs_storage._name {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransactionCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TransactionCluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "transactions"),
    3: .same(proto: "score"),
    4: .standard(proto: "categorization_improvement"),
  ]

  fileprivate class _StorageClass {
    var _description_p: String = String()
    var _transactions: [Transaction] = []
    var _score: ExactNumber? = nil
    var _categorizationImprovement: ExactNumber? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _description_p = source._description_p
      _transactions = source._transactions
      _score = source._score
      _categorizationImprovement = source._categorizationImprovement
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._transactions)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._score)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._categorizationImprovement)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 1)
      }
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 2)
      }
      if let v = _storage._score {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._categorizationImprovement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransactionCluster, rhs: TransactionCluster) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._transactions != rhs_storage._transactions {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._categorizationImprovement != rhs_storage._categorizationImprovement {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransferDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TransferDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "name"),
    3: .same(proto: "balance"),
    4: .standard(proto: "display_bank_name"),
    5: .same(proto: "type"),
    6: .same(proto: "images"),
    7: .standard(proto: "display_account_number"),
    8: .standard(proto: "matches_multiple"),
  ]

  fileprivate class _StorageClass {
    var _uri: String = String()
    var _name: String = String()
    var _balance: CurrencyDenominatedAmount? = nil
    var _displayBankName: String = String()
    var _type: Account.TypeEnum = .unknown
    var _images: Images? = nil
    var _displayAccountNumber: String = String()
    var _matchesMultiple: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uri = source._uri
      _name = source._name
      _balance = source._balance
      _displayBankName = source._displayBankName
      _type = source._type
      _images = source._images
      _displayAccountNumber = source._displayAccountNumber
      _matchesMultiple = source._matchesMultiple
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._uri)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 4: try decoder.decodeSingularStringField(value: &_storage._displayBankName)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._images)
        case 7: try decoder.decodeSingularStringField(value: &_storage._displayAccountNumber)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._matchesMultiple)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._uri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uri, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._displayBankName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayBankName, fieldNumber: 4)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 5)
      }
      if let v = _storage._images {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._displayAccountNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayAccountNumber, fieldNumber: 7)
      }
      if _storage._matchesMultiple != false {
        try visitor.visitSingularBoolField(value: _storage._matchesMultiple, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransferDestination, rhs: TransferDestination) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uri != rhs_storage._uri {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._displayBankName != rhs_storage._displayBankName {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._displayAccountNumber != rhs_storage._displayAccountNumber {return false}
        if _storage._matchesMultiple != rhs_storage._matchesMultiple {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TransferDestinationPerAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TransferDestinationPerAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "destinations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.destinations)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.destinations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.destinations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransferDestinationPerAccount, rhs: TransferDestinationPerAccount) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.destinations != rhs.destinations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Transfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "credential_id"),
    3: .standard(proto: "destination_uri"),
    4: .standard(proto: "destination_message"),
    5: .same(proto: "id"),
    6: .standard(proto: "source_uri"),
    7: .standard(proto: "source_message"),
    8: .same(proto: "type"),
    9: .standard(proto: "due_date"),
  ]

  fileprivate class _StorageClass {
    var _amount: CurrencyDenominatedAmount? = nil
    var _credentialID: String = String()
    var _destinationUri: String = String()
    var _destinationMessage: String = String()
    var _id: String = String()
    var _sourceUri: String = String()
    var _sourceMessage: String = String()
    var _type: Transfer.TypeEnum = .unknown
    var _dueDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _amount = source._amount
      _credentialID = source._credentialID
      _destinationUri = source._destinationUri
      _destinationMessage = source._destinationMessage
      _id = source._id
      _sourceUri = source._sourceUri
      _sourceMessage = source._sourceMessage
      _type = source._type
      _dueDate = source._dueDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 2: try decoder.decodeSingularStringField(value: &_storage._credentialID)
        case 3: try decoder.decodeSingularStringField(value: &_storage._destinationUri)
        case 4: try decoder.decodeSingularStringField(value: &_storage._destinationMessage)
        case 5: try decoder.decodeSingularStringField(value: &_storage._id)
        case 6: try decoder.decodeSingularStringField(value: &_storage._sourceUri)
        case 7: try decoder.decodeSingularStringField(value: &_storage._sourceMessage)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._dueDate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._credentialID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._credentialID, fieldNumber: 2)
      }
      if !_storage._destinationUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._destinationUri, fieldNumber: 3)
      }
      if !_storage._destinationMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._destinationMessage, fieldNumber: 4)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 5)
      }
      if !_storage._sourceUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourceUri, fieldNumber: 6)
      }
      if !_storage._sourceMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourceMessage, fieldNumber: 7)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 8)
      }
      if let v = _storage._dueDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Transfer, rhs: Transfer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._credentialID != rhs_storage._credentialID {return false}
        if _storage._destinationUri != rhs_storage._destinationUri {return false}
        if _storage._destinationMessage != rhs_storage._destinationMessage {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._sourceUri != rhs_storage._sourceUri {return false}
        if _storage._sourceMessage != rhs_storage._sourceMessage {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._dueDate != rhs_storage._dueDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transfer.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_EINVOICE"),
    2: .same(proto: "TYPE_PAYMENT"),
    3: .same(proto: "TYPE_BANK_TRANSFER"),
  ]
}

extension UserProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .standard(proto: "national_id"),
    3: .standard(proto: "authorized_login_methods"),
    4: .standard(proto: "available_login_methods"),
    5: .standard(proto: "created_date"),
  ]

  fileprivate class _StorageClass {
    var _username: String = String()
    var _nationalID: String = String()
    var _authorizedLoginMethods: [AuthenticationMethod] = []
    var _availableLoginMethods: [AuthenticationMethod] = []
    var _createdDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _username = source._username
      _nationalID = source._nationalID
      _authorizedLoginMethods = source._authorizedLoginMethods
      _availableLoginMethods = source._availableLoginMethods
      _createdDate = source._createdDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._username)
        case 2: try decoder.decodeSingularStringField(value: &_storage._nationalID)
        case 3: try decoder.decodeRepeatedEnumField(value: &_storage._authorizedLoginMethods)
        case 4: try decoder.decodeRepeatedEnumField(value: &_storage._availableLoginMethods)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._createdDate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 1)
      }
      if !_storage._nationalID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nationalID, fieldNumber: 2)
      }
      if !_storage._authorizedLoginMethods.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._authorizedLoginMethods, fieldNumber: 3)
      }
      if !_storage._availableLoginMethods.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._availableLoginMethods, fieldNumber: 4)
      }
      if let v = _storage._createdDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserProfile, rhs: UserProfile) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._username != rhs_storage._username {return false}
        if _storage._nationalID != rhs_storage._nationalID {return false}
        if _storage._authorizedLoginMethods != rhs_storage._authorizedLoginMethods {return false}
        if _storage._availableLoginMethods != rhs_storage._availableLoginMethods {return false}
        if _storage._createdDate != rhs_storage._createdDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .standard(proto: "i18n_configuration"),
    3: .standard(proto: "user_id"),
  ]

  fileprivate class _StorageClass {
    var _flags: [String] = []
    var _i18NConfiguration: UserConfiguration.I18NConfiguration? = nil
    var _userID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _flags = source._flags
      _i18NConfiguration = source._i18NConfiguration
      _userID = source._userID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._flags)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._i18NConfiguration)
        case 3: try decoder.decodeSingularStringField(value: &_storage._userID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._flags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._flags, fieldNumber: 1)
      }
      if let v = _storage._i18NConfiguration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserConfiguration, rhs: UserConfiguration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._i18NConfiguration != rhs_storage._i18NConfiguration {return false}
        if _storage._userID != rhs_storage._userID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserConfiguration.I18NConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = UserConfiguration.protoMessageName + ".I18NConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "currency_code"),
    2: .standard(proto: "locale_code"),
    3: .standard(proto: "market_code"),
    4: .standard(proto: "timezone_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.currencyCode)
      case 2: try decoder.decodeSingularStringField(value: &self.localeCode)
      case 3: try decoder.decodeSingularStringField(value: &self.marketCode)
      case 4: try decoder.decodeSingularStringField(value: &self.timezoneCode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 1)
    }
    if !self.localeCode.isEmpty {
      try visitor.visitSingularStringField(value: self.localeCode, fieldNumber: 2)
    }
    if !self.marketCode.isEmpty {
      try visitor.visitSingularStringField(value: self.marketCode, fieldNumber: 3)
    }
    if !self.timezoneCode.isEmpty {
      try visitor.visitSingularStringField(value: self.timezoneCode, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserConfiguration.I18NConfiguration, rhs: UserConfiguration.I18NConfiguration) -> Bool {
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.localeCode != rhs.localeCode {return false}
    if lhs.marketCode != rhs.marketCode {return false}
    if lhs.timezoneCode != rhs.timezoneCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension I18NSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "I18NSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "locale_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.localeCode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localeCode.isEmpty {
      try visitor.visitSingularStringField(value: self.localeCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: I18NSettings, rhs: I18NSettings) -> Bool {
    if lhs.localeCode != rhs.localeCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeriodSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PeriodSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "period_date_break_type"),
    2: .standard(proto: "monthly_adjusted_day"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.periodDateBreakType)
      case 2: try decoder.decodeSingularInt32Field(value: &self.monthlyAdjustedDay)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.periodDateBreakType != .unknown {
      try visitor.visitSingularEnumField(value: self.periodDateBreakType, fieldNumber: 1)
    }
    if self.monthlyAdjustedDay != 0 {
      try visitor.visitSingularInt32Field(value: self.monthlyAdjustedDay, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PeriodSettings, rhs: PeriodSettings) -> Bool {
    if lhs.periodDateBreakType != rhs.periodDateBreakType {return false}
    if lhs.monthlyAdjustedDay != rhs.monthlyAdjustedDay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NotificationSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groups)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationSettings, rhs: NotificationSettings) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NotificationGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "notification_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.title)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.notificationTypes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.notificationTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notificationTypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationGroup, rhs: NotificationGroup) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.notificationTypes != rhs.notificationTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NotificationType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "title"),
    3: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.title)
      case 3: try decoder.decodeSingularBoolField(value: &self.enabled)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationType, rhs: NotificationType) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.title != rhs.title {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserOrigin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserOrigin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "serviceName"),
    3: .same(proto: "organic"),
    4: .standard(proto: "external_service_id"),
    5: .standard(proto: "media_source"),
    6: .same(proto: "campaign"),
    7: .same(proto: "agency"),
    8: .standard(proto: "click_time"),
    9: .standard(proto: "install_time"),
    10: .standard(proto: "extra_param1"),
    11: .standard(proto: "extra_param2"),
    12: .standard(proto: "extra_param3"),
    13: .standard(proto: "extra_param4"),
    14: .standard(proto: "extra_param5"),
    15: .standard(proto: "facebook_ad"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _serviceName: String = String()
    var _organic: Bool = false
    var _externalServiceID: String = String()
    var _mediaSource: String = String()
    var _campaign: String = String()
    var _agency: String = String()
    var _clickTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _installTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _extraParam1: String = String()
    var _extraParam2: String = String()
    var _extraParam3: String = String()
    var _extraParam4: String = String()
    var _extraParam5: String = String()
    var _facebookAd: FacebookAd? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _serviceName = source._serviceName
      _organic = source._organic
      _externalServiceID = source._externalServiceID
      _mediaSource = source._mediaSource
      _campaign = source._campaign
      _agency = source._agency
      _clickTime = source._clickTime
      _installTime = source._installTime
      _extraParam1 = source._extraParam1
      _extraParam2 = source._extraParam2
      _extraParam3 = source._extraParam3
      _extraParam4 = source._extraParam4
      _extraParam5 = source._extraParam5
      _facebookAd = source._facebookAd
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._serviceName)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._organic)
        case 4: try decoder.decodeSingularStringField(value: &_storage._externalServiceID)
        case 5: try decoder.decodeSingularStringField(value: &_storage._mediaSource)
        case 6: try decoder.decodeSingularStringField(value: &_storage._campaign)
        case 7: try decoder.decodeSingularStringField(value: &_storage._agency)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._clickTime)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._installTime)
        case 10: try decoder.decodeSingularStringField(value: &_storage._extraParam1)
        case 11: try decoder.decodeSingularStringField(value: &_storage._extraParam2)
        case 12: try decoder.decodeSingularStringField(value: &_storage._extraParam3)
        case 13: try decoder.decodeSingularStringField(value: &_storage._extraParam4)
        case 14: try decoder.decodeSingularStringField(value: &_storage._extraParam5)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._facebookAd)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._serviceName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serviceName, fieldNumber: 2)
      }
      if _storage._organic != false {
        try visitor.visitSingularBoolField(value: _storage._organic, fieldNumber: 3)
      }
      if !_storage._externalServiceID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._externalServiceID, fieldNumber: 4)
      }
      if !_storage._mediaSource.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mediaSource, fieldNumber: 5)
      }
      if !_storage._campaign.isEmpty {
        try visitor.visitSingularStringField(value: _storage._campaign, fieldNumber: 6)
      }
      if !_storage._agency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._agency, fieldNumber: 7)
      }
      if let v = _storage._clickTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._installTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._extraParam1.isEmpty {
        try visitor.visitSingularStringField(value: _storage._extraParam1, fieldNumber: 10)
      }
      if !_storage._extraParam2.isEmpty {
        try visitor.visitSingularStringField(value: _storage._extraParam2, fieldNumber: 11)
      }
      if !_storage._extraParam3.isEmpty {
        try visitor.visitSingularStringField(value: _storage._extraParam3, fieldNumber: 12)
      }
      if !_storage._extraParam4.isEmpty {
        try visitor.visitSingularStringField(value: _storage._extraParam4, fieldNumber: 13)
      }
      if !_storage._extraParam5.isEmpty {
        try visitor.visitSingularStringField(value: _storage._extraParam5, fieldNumber: 14)
      }
      if let v = _storage._facebookAd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserOrigin, rhs: UserOrigin) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._serviceName != rhs_storage._serviceName {return false}
        if _storage._organic != rhs_storage._organic {return false}
        if _storage._externalServiceID != rhs_storage._externalServiceID {return false}
        if _storage._mediaSource != rhs_storage._mediaSource {return false}
        if _storage._campaign != rhs_storage._campaign {return false}
        if _storage._agency != rhs_storage._agency {return false}
        if _storage._clickTime != rhs_storage._clickTime {return false}
        if _storage._installTime != rhs_storage._installTime {return false}
        if _storage._extraParam1 != rhs_storage._extraParam1 {return false}
        if _storage._extraParam2 != rhs_storage._extraParam2 {return false}
        if _storage._extraParam3 != rhs_storage._extraParam3 {return false}
        if _storage._extraParam4 != rhs_storage._extraParam4 {return false}
        if _storage._extraParam5 != rhs_storage._extraParam5 {return false}
        if _storage._facebookAd != rhs_storage._facebookAd {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FacebookAd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FacebookAd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "group_name"),
    3: .standard(proto: "campaign_id"),
    4: .standard(proto: "ad_set_id"),
    5: .standard(proto: "ad_set_name"),
    6: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.groupID)
      case 2: try decoder.decodeSingularStringField(value: &self.groupName)
      case 3: try decoder.decodeSingularStringField(value: &self.campaignID)
      case 4: try decoder.decodeSingularStringField(value: &self.adSetID)
      case 5: try decoder.decodeSingularStringField(value: &self.adSetName)
      case 6: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    if !self.campaignID.isEmpty {
      try visitor.visitSingularStringField(value: self.campaignID, fieldNumber: 3)
    }
    if !self.adSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.adSetID, fieldNumber: 4)
    }
    if !self.adSetName.isEmpty {
      try visitor.visitSingularStringField(value: self.adSetName, fieldNumber: 5)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FacebookAd, rhs: FacebookAd) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.adSetID != rhs.adSetID {return false}
    if lhs.adSetName != rhs.adSetName {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthenticationKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AuthenticationKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_type"),
    2: .same(proto: "id"),
    3: .same(proto: "key"),
    4: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.keyType)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      case 3: try decoder.decodeSingularStringField(value: &self.key)
      case 4: try decoder.decodeSingularEnumField(value: &self.source)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyType != .keyTypeUnknown {
      try visitor.visitSingularEnumField(value: self.keyType, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AuthenticationKey, rhs: AuthenticationKey) -> Bool {
    if lhs.keyType != rhs.keyType {return false}
    if lhs.id != rhs.id {return false}
    if lhs.key != rhs.key {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityEventAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityEventAnswer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.label)
      case 2: try decoder.decodeSingularEnumField(value: &self.key)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if self.key != .unknown {
      try visitor.visitSingularEnumField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityEventAnswer, rhs: IdentityEventAnswer) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "date"),
    3: .same(proto: "description"),
    4: .same(proto: "seen"),
    5: .same(proto: "question"),
    6: .standard(proto: "potential_answers"),
    7: .same(proto: "answer"),
    8: .same(proto: "documentation"),
    9: .same(proto: "transactions"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _seen: Bool = false
    var _question: String = String()
    var _potentialAnswers: [IdentityEventAnswer] = []
    var _answer: IdentityDocumentedAnswer? = nil
    var _documentation: IdentityEventDocumentation? = nil
    var _transactions: [Transaction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _date = source._date
      _description_p = source._description_p
      _seen = source._seen
      _question = source._question
      _potentialAnswers = source._potentialAnswers
      _answer = source._answer
      _documentation = source._documentation
      _transactions = source._transactions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 3: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._seen)
        case 5: try decoder.decodeSingularStringField(value: &_storage._question)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._potentialAnswers)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._answer)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._documentation)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._transactions)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if _storage._seen != false {
        try visitor.visitSingularBoolField(value: _storage._seen, fieldNumber: 4)
      }
      if !_storage._question.isEmpty {
        try visitor.visitSingularStringField(value: _storage._question, fieldNumber: 5)
      }
      if !_storage._potentialAnswers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._potentialAnswers, fieldNumber: 6)
      }
      if let v = _storage._answer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._documentation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityEvent, rhs: IdentityEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._seen != rhs_storage._seen {return false}
        if _storage._question != rhs_storage._question {return false}
        if _storage._potentialAnswers != rhs_storage._potentialAnswers {return false}
        if _storage._answer != rhs_storage._answer {return false}
        if _storage._documentation != rhs_storage._documentation {return false}
        if _storage._transactions != rhs_storage._transactions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityEventSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityEventSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "date"),
    3: .same(proto: "description"),
    4: .same(proto: "seen"),
    5: .same(proto: "answer"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _seen: Bool = false
    var _answer: IdentityDocumentedAnswer? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _date = source._date
      _description_p = source._description_p
      _seen = source._seen
      _answer = source._answer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 3: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._seen)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._answer)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if _storage._seen != false {
        try visitor.visitSingularBoolField(value: _storage._seen, fieldNumber: 4)
      }
      if let v = _storage._answer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityEventSummary, rhs: IdentityEventSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._seen != rhs_storage._seen {return false}
        if _storage._answer != rhs_storage._answer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityEventDocumentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityEventDocumentation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "info_title"),
    3: .standard(proto: "info_body"),
    4: .standard(proto: "help_title"),
    5: .standard(proto: "help_body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.source)
      case 2: try decoder.decodeSingularStringField(value: &self.infoTitle)
      case 3: try decoder.decodeSingularStringField(value: &self.infoBody)
      case 4: try decoder.decodeSingularStringField(value: &self.helpTitle)
      case 5: try decoder.decodeSingularStringField(value: &self.helpBody)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if !self.infoTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.infoTitle, fieldNumber: 2)
    }
    if !self.infoBody.isEmpty {
      try visitor.visitSingularStringField(value: self.infoBody, fieldNumber: 3)
    }
    if !self.helpTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.helpTitle, fieldNumber: 4)
    }
    if !self.helpBody.isEmpty {
      try visitor.visitSingularStringField(value: self.helpBody, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityEventDocumentation, rhs: IdentityEventDocumentation) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.infoTitle != rhs.infoTitle {return false}
    if lhs.infoBody != rhs.infoBody {return false}
    if lhs.helpTitle != rhs.helpTitle {return false}
    if lhs.helpBody != rhs.helpBody {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityStateAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityStateAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "postal_code"),
    3: .same(proto: "city"),
    4: .same(proto: "community"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.postalCode)
      case 3: try decoder.decodeSingularStringField(value: &self.city)
      case 4: try decoder.decodeSingularStringField(value: &self.community)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.postalCode.isEmpty {
      try visitor.visitSingularStringField(value: self.postalCode, fieldNumber: 2)
    }
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 3)
    }
    if !self.community.isEmpty {
      try visitor.visitSingularStringField(value: self.community, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityStateAddress, rhs: IdentityStateAddress) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.postalCode != rhs.postalCode {return false}
    if lhs.city != rhs.city {return false}
    if lhs.community != rhs.community {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityStateProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityStateProperty"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "municipality"),
    3: .same(proto: "number"),
    4: .standard(proto: "acquisition_date"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _municipality: String = String()
    var _number: String = String()
    var _acquisitionDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _municipality = source._municipality
      _number = source._number
      _acquisitionDate = source._acquisitionDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._municipality)
        case 3: try decoder.decodeSingularStringField(value: &_storage._number)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._acquisitionDate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._municipality.isEmpty {
        try visitor.visitSingularStringField(value: _storage._municipality, fieldNumber: 2)
      }
      if !_storage._number.isEmpty {
        try visitor.visitSingularStringField(value: _storage._number, fieldNumber: 3)
      }
      if let v = _storage._acquisitionDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityStateProperty, rhs: IdentityStateProperty) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._municipality != rhs_storage._municipality {return false}
        if _storage._number != rhs_storage._number {return false}
        if _storage._acquisitionDate != rhs_storage._acquisitionDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityStateCompany: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityStateCompany"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.number)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityStateCompany, rhs: IdentityStateCompany) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityStateRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityStateRole"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityStateRole, rhs: IdentityStateRole) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityStateCompanyEngagement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityStateCompanyEngagement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "company"),
    2: .same(proto: "roles"),
    4: .standard(proto: "date_in"),
  ]

  fileprivate class _StorageClass {
    var _company: IdentityStateCompany? = nil
    var _roles: [IdentityStateRole] = []
    var _dateIn: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _company = source._company
      _roles = source._roles
      _dateIn = source._dateIn
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._company)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._roles)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._dateIn)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._company {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._roles, fieldNumber: 2)
      }
      if let v = _storage._dateIn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityStateCompanyEngagement, rhs: IdentityStateCompanyEngagement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._company != rhs_storage._company {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._dateIn != rhs_storage._dateIn {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityStateCreditScore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityStateCreditScore"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "score"),
    3: .standard(proto: "max_score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.text)
      case 2: try decoder.decodeSingularInt32Field(value: &self.score)
      case 3: try decoder.decodeSingularInt32Field(value: &self.maxScore)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.score != 0 {
      try visitor.visitSingularInt32Field(value: self.score, fieldNumber: 2)
    }
    if self.maxScore != 0 {
      try visitor.visitSingularInt32Field(value: self.maxScore, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityStateCreditScore, rhs: IdentityStateCreditScore) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.score != rhs.score {return false}
    if lhs.maxScore != rhs.maxScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityStateTaxDeclaration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityStateTaxDeclaration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "final_tax"),
    2: .standard(proto: "total_income"),
    3: .standard(proto: "income_by_service"),
    4: .standard(proto: "income_by_capital"),
    5: .same(proto: "year"),
    6: .standard(proto: "registered_date"),
  ]

  fileprivate class _StorageClass {
    var _finalTax: CurrencyDenominatedAmount? = nil
    var _totalIncome: CurrencyDenominatedAmount? = nil
    var _incomeByService: CurrencyDenominatedAmount? = nil
    var _incomeByCapital: CurrencyDenominatedAmount? = nil
    var _year: Int32 = 0
    var _registeredDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _finalTax = source._finalTax
      _totalIncome = source._totalIncome
      _incomeByService = source._incomeByService
      _incomeByCapital = source._incomeByCapital
      _year = source._year
      _registeredDate = source._registeredDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._finalTax)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._totalIncome)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._incomeByService)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._incomeByCapital)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._year)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._registeredDate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._finalTax {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._totalIncome {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._incomeByService {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._incomeByCapital {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._year != 0 {
        try visitor.visitSingularInt32Field(value: _storage._year, fieldNumber: 5)
      }
      if let v = _storage._registeredDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityStateTaxDeclaration, rhs: IdentityStateTaxDeclaration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._finalTax != rhs_storage._finalTax {return false}
        if _storage._totalIncome != rhs_storage._totalIncome {return false}
        if _storage._incomeByService != rhs_storage._incomeByService {return false}
        if _storage._incomeByCapital != rhs_storage._incomeByCapital {return false}
        if _storage._year != rhs_storage._year {return false}
        if _storage._registeredDate != rhs_storage._registeredDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityStateRecordOfNonPayment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityStateRecordOfNonPayment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "amount"),
    3: .standard(proto: "registered_date"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _amount: CurrencyDenominatedAmount? = nil
    var _registeredDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _amount = source._amount
      _registeredDate = source._registeredDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._registeredDate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._registeredDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityStateRecordOfNonPayment, rhs: IdentityStateRecordOfNonPayment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._registeredDate != rhs_storage._registeredDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityStateOutstandingDebt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityStateOutstandingDebt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "number"),
    3: .standard(proto: "registered_date"),
  ]

  fileprivate class _StorageClass {
    var _amount: CurrencyDenominatedAmount? = nil
    var _number: Int32 = 0
    var _registeredDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _amount = source._amount
      _number = source._number
      _registeredDate = source._registeredDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._number)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._registeredDate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._number != 0 {
        try visitor.visitSingularInt32Field(value: _storage._number, fieldNumber: 2)
      }
      if let v = _storage._registeredDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityStateOutstandingDebt, rhs: IdentityStateOutstandingDebt) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._number != rhs_storage._number {return false}
        if _storage._registeredDate != rhs_storage._registeredDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "first_name"),
    2: .standard(proto: "last_name"),
    3: .standard(proto: "national_id"),
    4: .same(proto: "address"),
    5: .same(proto: "properties"),
    6: .standard(proto: "company_engagements"),
    7: .standard(proto: "credit_score"),
    8: .standard(proto: "most_recent_tax_declaration"),
    9: .standard(proto: "records_of_non_payment"),
    10: .standard(proto: "outstanding_debt"),
  ]

  fileprivate class _StorageClass {
    var _firstName: String = String()
    var _lastName: String = String()
    var _nationalID: String = String()
    var _address: IdentityStateAddress? = nil
    var _properties: [IdentityStateProperty] = []
    var _companyEngagements: [IdentityStateCompanyEngagement] = []
    var _creditScore: IdentityStateCreditScore? = nil
    var _mostRecentTaxDeclaration: IdentityStateTaxDeclaration? = nil
    var _recordsOfNonPayment: [IdentityStateRecordOfNonPayment] = []
    var _outstandingDebt: IdentityStateOutstandingDebt? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _firstName = source._firstName
      _lastName = source._lastName
      _nationalID = source._nationalID
      _address = source._address
      _properties = source._properties
      _companyEngagements = source._companyEngagements
      _creditScore = source._creditScore
      _mostRecentTaxDeclaration = source._mostRecentTaxDeclaration
      _recordsOfNonPayment = source._recordsOfNonPayment
      _outstandingDebt = source._outstandingDebt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._firstName)
        case 2: try decoder.decodeSingularStringField(value: &_storage._lastName)
        case 3: try decoder.decodeSingularStringField(value: &_storage._nationalID)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._address)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._properties)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._companyEngagements)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._creditScore)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._mostRecentTaxDeclaration)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._recordsOfNonPayment)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._outstandingDebt)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._firstName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstName, fieldNumber: 1)
      }
      if !_storage._lastName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastName, fieldNumber: 2)
      }
      if !_storage._nationalID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nationalID, fieldNumber: 3)
      }
      if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._properties.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._properties, fieldNumber: 5)
      }
      if !_storage._companyEngagements.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._companyEngagements, fieldNumber: 6)
      }
      if let v = _storage._creditScore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._mostRecentTaxDeclaration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._recordsOfNonPayment.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._recordsOfNonPayment, fieldNumber: 9)
      }
      if let v = _storage._outstandingDebt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityState, rhs: IdentityState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._nationalID != rhs_storage._nationalID {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._companyEngagements != rhs_storage._companyEngagements {return false}
        if _storage._creditScore != rhs_storage._creditScore {return false}
        if _storage._mostRecentTaxDeclaration != rhs_storage._mostRecentTaxDeclaration {return false}
        if _storage._recordsOfNonPayment != rhs_storage._recordsOfNonPayment {return false}
        if _storage._outstandingDebt != rhs_storage._outstandingDebt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IdentityDocumentedAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IdentityDocumentedAnswer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.answer)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.answer != .unknown {
      try visitor.visitSingularEnumField(value: self.answer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IdentityDocumentedAnswer, rhs: IdentityDocumentedAnswer) -> Bool {
    if lhs.answer != rhs.answer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Consent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Consent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "version"),
    3: .same(proto: "title"),
    4: .same(proto: "body"),
    5: .same(proto: "checksum"),
    6: .same(proto: "messages"),
    7: .same(proto: "attachments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.version)
      case 3: try decoder.decodeSingularStringField(value: &self.title)
      case 4: try decoder.decodeSingularStringField(value: &self.body)
      case 5: try decoder.decodeSingularStringField(value: &self.checksum)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.messages)
      case 7: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attachments)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 4)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 6)
    }
    if !self.attachments.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attachments, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Consent, rhs: Consent) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.version != rhs.version {return false}
    if lhs.title != rhs.title {return false}
    if lhs.body != rhs.body {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserConsent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserConsent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
    3: .same(proto: "version"),
    4: .same(proto: "action"),
    5: .same(proto: "timestamp"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _key: String = String()
    var _version: String = String()
    var _action: ConsentAction = .unknown
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _key = source._key
      _version = source._version
      _action = source._action
      _timestamp = source._timestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._key)
        case 3: try decoder.decodeSingularStringField(value: &_storage._version)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._action)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      if _storage._action != .unknown {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 4)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserConsent, rhs: UserConsent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConsentMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConsentMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "links"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.message)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.links)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConsentMessage, rhs: ConsentMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConsentMessageLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConsentMessageLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.to)
      case 2: try decoder.decodeSingularInt32Field(value: &self.start)
      case 3: try decoder.decodeSingularInt32Field(value: &self.end)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 1)
    }
    if self.start != 0 {
      try visitor.visitSingularInt32Field(value: self.start, fieldNumber: 2)
    }
    if self.end != 0 {
      try visitor.visitSingularInt32Field(value: self.end, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConsentMessageLink, rhs: ConsentMessageLink) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ThirdPartyAppAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ThirdPartyAppAuthentication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_title"),
    2: .standard(proto: "download_message"),
    3: .standard(proto: "upgrade_title"),
    4: .standard(proto: "upgrade_message"),
    5: .same(proto: "ios"),
    6: .same(proto: "android"),
    7: .same(proto: "web"),
  ]

  fileprivate class _StorageClass {
    var _downloadTitle: String = String()
    var _downloadMessage: String = String()
    var _upgradeTitle: String = String()
    var _upgradeMessage: String = String()
    var _ios: ThirdPartyAppAuthentication.Ios? = nil
    var _android: ThirdPartyAppAuthentication.Android? = nil
    var _web: ThirdPartyAppAuthentication.Web? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _downloadTitle = source._downloadTitle
      _downloadMessage = source._downloadMessage
      _upgradeTitle = source._upgradeTitle
      _upgradeMessage = source._upgradeMessage
      _ios = source._ios
      _android = source._android
      _web = source._web
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._downloadTitle)
        case 2: try decoder.decodeSingularStringField(value: &_storage._downloadMessage)
        case 3: try decoder.decodeSingularStringField(value: &_storage._upgradeTitle)
        case 4: try decoder.decodeSingularStringField(value: &_storage._upgradeMessage)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._ios)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._android)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._web)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._downloadTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._downloadTitle, fieldNumber: 1)
      }
      if !_storage._downloadMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._downloadMessage, fieldNumber: 2)
      }
      if !_storage._upgradeTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._upgradeTitle, fieldNumber: 3)
      }
      if !_storage._upgradeMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._upgradeMessage, fieldNumber: 4)
      }
      if let v = _storage._ios {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._android {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._web {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ThirdPartyAppAuthentication, rhs: ThirdPartyAppAuthentication) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._downloadTitle != rhs_storage._downloadTitle {return false}
        if _storage._downloadMessage != rhs_storage._downloadMessage {return false}
        if _storage._upgradeTitle != rhs_storage._upgradeTitle {return false}
        if _storage._upgradeMessage != rhs_storage._upgradeMessage {return false}
        if _storage._ios != rhs_storage._ios {return false}
        if _storage._android != rhs_storage._android {return false}
        if _storage._web != rhs_storage._web {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ThirdPartyAppAuthentication.Ios: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ThirdPartyAppAuthentication.protoMessageName + ".Ios"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_store_url"),
    2: .same(proto: "scheme"),
    3: .standard(proto: "deep_link_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.appStoreURL)
      case 2: try decoder.decodeSingularStringField(value: &self.scheme)
      case 3: try decoder.decodeSingularStringField(value: &self.deepLinkURL)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appStoreURL.isEmpty {
      try visitor.visitSingularStringField(value: self.appStoreURL, fieldNumber: 1)
    }
    if !self.scheme.isEmpty {
      try visitor.visitSingularStringField(value: self.scheme, fieldNumber: 2)
    }
    if !self.deepLinkURL.isEmpty {
      try visitor.visitSingularStringField(value: self.deepLinkURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ThirdPartyAppAuthentication.Ios, rhs: ThirdPartyAppAuthentication.Ios) -> Bool {
    if lhs.appStoreURL != rhs.appStoreURL {return false}
    if lhs.scheme != rhs.scheme {return false}
    if lhs.deepLinkURL != rhs.deepLinkURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ThirdPartyAppAuthentication.Android: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ThirdPartyAppAuthentication.protoMessageName + ".Android"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "package_name"),
    2: .standard(proto: "required_minimum_version"),
    3: .same(proto: "intent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.packageName)
      case 2: try decoder.decodeSingularInt32Field(value: &self.requiredMinimumVersion)
      case 3: try decoder.decodeSingularStringField(value: &self.intent)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packageName.isEmpty {
      try visitor.visitSingularStringField(value: self.packageName, fieldNumber: 1)
    }
    if self.requiredMinimumVersion != 0 {
      try visitor.visitSingularInt32Field(value: self.requiredMinimumVersion, fieldNumber: 2)
    }
    if !self.intent.isEmpty {
      try visitor.visitSingularStringField(value: self.intent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ThirdPartyAppAuthentication.Android, rhs: ThirdPartyAppAuthentication.Android) -> Bool {
    if lhs.packageName != rhs.packageName {return false}
    if lhs.requiredMinimumVersion != rhs.requiredMinimumVersion {return false}
    if lhs.intent != rhs.intent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ThirdPartyAppAuthentication.Web: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ThirdPartyAppAuthentication.protoMessageName + ".Web"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.url)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ThirdPartyAppAuthentication.Web, rhs: ThirdPartyAppAuthentication.Web) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Credentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Credentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credential"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.credential)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.credential.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credential, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Credentials, rhs: Credentials) -> Bool {
    if lhs.credential != rhs.credential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Accounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Accounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.account)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.account, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Accounts, rhs: Accounts) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Transactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transaction)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Transactions, rhs: Transactions) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Providers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Providers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.provider)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.provider.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.provider, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Providers, rhs: Providers) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Periods: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Periods"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Period>.self, value: &self.period)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.period.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Period>.self, value: self.period, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Periods, rhs: Periods) -> Bool {
    if lhs.period != rhs.period {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FollowItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FollowItems"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "follow_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.followItem)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.followItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.followItem, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FollowItems, rhs: FollowItems) -> Bool {
    if lhs.followItem != rhs.followItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignableOperations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SignableOperations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signable_operation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.signableOperation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signableOperation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signableOperation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SignableOperations, rhs: SignableOperations) -> Bool {
    if lhs.signableOperation != rhs.signableOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BudgetSummaries: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BudgetSummaries"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "budget_summaries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.budgetSummaries)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.budgetSummaries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.budgetSummaries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BudgetSummaries, rhs: BudgetSummaries) -> Bool {
    if lhs.budgetSummaries != rhs.budgetSummaries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Insights: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Insights"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "insights"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.insights)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.insights.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insights, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Insights, rhs: Insights) -> Bool {
    if lhs.insights != rhs.insights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightsCategories: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InsightsCategories"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "body"),
    3: .standard(proto: "amount_by_category_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.title)
      case 2: try decoder.decodeSingularStringField(value: &self.body)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.amountByCategoryCode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 2)
    }
    if !self.amountByCategoryCode.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amountByCategoryCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightsCategories, rhs: InsightsCategories) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.body != rhs.body {return false}
    if lhs.amountByCategoryCode != rhs.amountByCategoryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightsCategories.AmountByCategoryCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = InsightsCategories.protoMessageName + ".AmountByCategoryCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "category_code"),
    2: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _categoryCode: String = String()
    var _amount: CurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _categoryCode = source._categoryCode
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._categoryCode)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._categoryCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._categoryCode, fieldNumber: 1)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightsCategories.AmountByCategoryCode, rhs: InsightsCategories.AmountByCategoryCode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._categoryCode != rhs_storage._categoryCode {return false}
        if _storage._amount != rhs_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightsMortgage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InsightsMortgage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "body"),
    3: .same(proto: "distribution"),
    4: .standard(proto: "interest_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.title)
      case 2: try decoder.decodeSingularStringField(value: &self.body)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.distribution)
      case 4: try decoder.decodeSingularDoubleField(value: &self.interestRate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 2)
    }
    if !self.distribution.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.distribution, fieldNumber: 3)
    }
    if self.interestRate != 0 {
      try visitor.visitSingularDoubleField(value: self.interestRate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightsMortgage, rhs: InsightsMortgage) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.body != rhs.body {return false}
    if lhs.distribution != rhs.distribution {return false}
    if lhs.interestRate != rhs.interestRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightsMortgage.HistogramBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = InsightsMortgage.protoMessageName + ".HistogramBucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lower_endpoint"),
    2: .standard(proto: "upper_endpoint"),
    3: .same(proto: "frequency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.lowerEndpoint)
      case 2: try decoder.decodeSingularDoubleField(value: &self.upperEndpoint)
      case 3: try decoder.decodeSingularDoubleField(value: &self.frequency)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lowerEndpoint != 0 {
      try visitor.visitSingularDoubleField(value: self.lowerEndpoint, fieldNumber: 1)
    }
    if self.upperEndpoint != 0 {
      try visitor.visitSingularDoubleField(value: self.upperEndpoint, fieldNumber: 2)
    }
    if self.frequency != 0 {
      try visitor.visitSingularDoubleField(value: self.frequency, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightsMortgage.HistogramBucket, rhs: InsightsMortgage.HistogramBucket) -> Bool {
    if lhs.lowerEndpoint != rhs.lowerEndpoint {return false}
    if lhs.upperEndpoint != rhs.upperEndpoint {return false}
    if lhs.frequency != rhs.frequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightsSavings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InsightsSavings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "body"),
    3: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _title: String = String()
    var _body: String = String()
    var _amount: CurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _body = source._body
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._title)
        case 2: try decoder.decodeSingularStringField(value: &_storage._body)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._body.isEmpty {
        try visitor.visitSingularStringField(value: _storage._body, fieldNumber: 2)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightsSavings, rhs: InsightsSavings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._body != rhs_storage._body {return false}
        if _storage._amount != rhs_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightsDailySpend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InsightsDailySpend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "body"),
    3: .standard(proto: "amount_by_weekday"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.title)
      case 2: try decoder.decodeSingularStringField(value: &self.body)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.amountByWeekday)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 2)
    }
    if !self.amountByWeekday.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amountByWeekday, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightsDailySpend, rhs: InsightsDailySpend) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.body != rhs.body {return false}
    if lhs.amountByWeekday != rhs.amountByWeekday {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightsDailySpend.AmountByWeekday: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = InsightsDailySpend.protoMessageName + ".AmountByWeekday"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weekday"),
    2: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _weekday: String = String()
    var _amount: CurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _weekday = source._weekday
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._weekday)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._weekday.isEmpty {
        try visitor.visitSingularStringField(value: _storage._weekday, fieldNumber: 1)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightsDailySpend.AmountByWeekday, rhs: InsightsDailySpend.AmountByWeekday) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._weekday != rhs_storage._weekday {return false}
        if _storage._amount != rhs_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightsLeftToSpend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InsightsLeftToSpend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "body"),
    3: .standard(proto: "left_to_spend_by_period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.title)
      case 2: try decoder.decodeSingularStringField(value: &self.body)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.leftToSpendByPeriod)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 2)
    }
    if !self.leftToSpendByPeriod.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leftToSpendByPeriod, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightsLeftToSpend, rhs: InsightsLeftToSpend) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.body != rhs.body {return false}
    if lhs.leftToSpendByPeriod != rhs.leftToSpendByPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightsLeftToSpend.LeftToSpendByPeriod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = InsightsLeftToSpend.protoMessageName + ".LeftToSpendByPeriod"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "period"),
    2: .same(proto: "percentage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.period)
      case 2: try decoder.decodeSingularDoubleField(value: &self.percentage)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.period.isEmpty {
      try visitor.visitSingularStringField(value: self.period, fieldNumber: 1)
    }
    if self.percentage != 0 {
      try visitor.visitSingularDoubleField(value: self.percentage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightsLeftToSpend.LeftToSpendByPeriod, rhs: InsightsLeftToSpend.LeftToSpendByPeriod) -> Bool {
    if lhs.period != rhs.period {return false}
    if lhs.percentage != rhs.percentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Application: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Application"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "forms"),
    3: .same(proto: "status"),
    4: .same(proto: "steps"),
    5: .same(proto: "title"),
    6: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _forms: ApplicationForms? = nil
    var _status: ApplicationStatus? = nil
    var _steps: Int32 = 0
    var _title: String = String()
    var _type: ApplicationType = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _forms = source._forms
      _status = source._status
      _steps = source._steps
      _title = source._title
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._forms)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._steps)
        case 5: try decoder.decodeSingularStringField(value: &_storage._title)
        case 6: try decoder.decodeSingularEnumField(value: &_storage._type)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._forms {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._steps != 0 {
        try visitor.visitSingularInt32Field(value: _storage._steps, fieldNumber: 4)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 5)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Application, rhs: Application) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._forms != rhs_storage._forms {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._steps != rhs_storage._steps {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "id"),
    3: .standard(proto: "image_url"),
    4: .same(proto: "progress"),
    5: .same(proto: "provider"),
    6: .same(proto: "status"),
    7: .same(proto: "title"),
    8: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _description_p: String = String()
    var _id: String = String()
    var _imageURL: String = String()
    var _progress: Double = 0
    var _provider: String = String()
    var _status: ApplicationSummaryStatus? = nil
    var _title: String = String()
    var _type: ApplicationType = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _description_p = source._description_p
      _id = source._id
      _imageURL = source._imageURL
      _progress = source._progress
      _provider = source._provider
      _status = source._status
      _title = source._title
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 2: try decoder.decodeSingularStringField(value: &_storage._id)
        case 3: try decoder.decodeSingularStringField(value: &_storage._imageURL)
        case 4: try decoder.decodeSingularDoubleField(value: &_storage._progress)
        case 5: try decoder.decodeSingularStringField(value: &_storage._provider)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._status)
        case 7: try decoder.decodeSingularStringField(value: &_storage._title)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._type)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 1)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      if !_storage._imageURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imageURL, fieldNumber: 3)
      }
      if _storage._progress != 0 {
        try visitor.visitSingularDoubleField(value: _storage._progress, fieldNumber: 4)
      }
      if !_storage._provider.isEmpty {
        try visitor.visitSingularStringField(value: _storage._provider, fieldNumber: 5)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 7)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationSummary, rhs: ApplicationSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._imageURL != rhs_storage._imageURL {return false}
        if _storage._progress != rhs_storage._progress {return false}
        if _storage._provider != rhs_storage._provider {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationSummaryStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationSummaryStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "body"),
    3: .same(proto: "payload"),
    4: .same(proto: "title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.body)
      case 3: try decoder.decodeSingularStringField(value: &self.payload)
      case 4: try decoder.decodeSingularStringField(value: &self.title)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != .applicationStatusUnknown {
      try visitor.visitSingularEnumField(value: self.key, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationSummaryStatus, rhs: ApplicationSummaryStatus) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.body != rhs.body {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationForms: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationForms"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "form"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.form)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.form.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.form, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationForms, rhs: ApplicationForms) -> Bool {
    if lhs.form != rhs.form {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationForm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationForm"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "application_id"),
    3: .same(proto: "description"),
    4: .same(proto: "fields"),
    5: .same(proto: "status"),
    6: .same(proto: "type"),
    7: .same(proto: "title"),
    8: .standard(proto: "serialized_payload"),
    9: .same(proto: "name"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _applicationID: String = String()
    var _description_p: String = String()
    var _fields: ApplicationFormFields? = nil
    var _status: ApplicationFormStatus? = nil
    var _type: String = String()
    var _title: String = String()
    var _serializedPayload: String = String()
    var _name: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _applicationID = source._applicationID
      _description_p = source._description_p
      _fields = source._fields
      _status = source._status
      _type = source._type
      _title = source._title
      _serializedPayload = source._serializedPayload
      _name = source._name
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._applicationID)
        case 3: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._fields)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._status)
        case 6: try decoder.decodeSingularStringField(value: &_storage._type)
        case 7: try decoder.decodeSingularStringField(value: &_storage._title)
        case 8: try decoder.decodeSingularStringField(value: &_storage._serializedPayload)
        case 9: try decoder.decodeSingularStringField(value: &_storage._name)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._applicationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._applicationID, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if let v = _storage._fields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 6)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 7)
      }
      if !_storage._serializedPayload.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serializedPayload, fieldNumber: 8)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationForm, rhs: ApplicationForm) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._applicationID != rhs_storage._applicationID {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._fields != rhs_storage._fields {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._serializedPayload != rhs_storage._serializedPayload {return false}
        if _storage._name != rhs_storage._name {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RequestApplicationForm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RequestApplicationForm"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "fields"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _fields: RequestApplicationFormFields? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _fields = source._fields
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fields)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._fields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RequestApplicationForm, rhs: RequestApplicationForm) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._fields != rhs_storage._fields {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RequestApplicationFormFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RequestApplicationFormFields"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.field)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RequestApplicationFormFields, rhs: RequestApplicationFormFields) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RequestApplicationFormField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RequestApplicationFormField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _value: SwiftProtobuf.Google_Protobuf_StringValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._value)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RequestApplicationFormField, rhs: RequestApplicationFormField) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationFormFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationFormFields"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.field)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationFormFields, rhs: ApplicationFormFields) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationFormField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationFormField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_value"),
    2: .same(proto: "description"),
    3: .same(proto: "errors"),
    4: .standard(proto: "display_error"),
    5: .same(proto: "label"),
    6: .same(proto: "name"),
    7: .same(proto: "options"),
    8: .same(proto: "pattern"),
    9: .same(proto: "type"),
    10: .same(proto: "value"),
    11: .same(proto: "required"),
    12: .same(proto: "readOnly"),
    13: .same(proto: "dependency"),
    14: .standard(proto: "info_title"),
    15: .standard(proto: "info_body"),
    16: .same(proto: "introduction"),
  ]

  fileprivate class _StorageClass {
    var _defaultValue: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _description_p: String = String()
    var _errors: ApplicationFormFieldErrors? = nil
    var _displayError: String = String()
    var _label: String = String()
    var _name: String = String()
    var _options: ApplicationFormFieldOptions? = nil
    var _pattern: String = String()
    var _type: ApplicationFieldType = .unknown
    var _value: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _required: Bool = false
    var _readOnly: Bool = false
    var _dependency: String = String()
    var _infoTitle: String = String()
    var _infoBody: String = String()
    var _introduction: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _defaultValue = source._defaultValue
      _description_p = source._description_p
      _errors = source._errors
      _displayError = source._displayError
      _label = source._label
      _name = source._name
      _options = source._options
      _pattern = source._pattern
      _type = source._type
      _value = source._value
      _required = source._required
      _readOnly = source._readOnly
      _dependency = source._dependency
      _infoTitle = source._infoTitle
      _infoBody = source._infoBody
      _introduction = source._introduction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._defaultValue)
        case 2: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._errors)
        case 4: try decoder.decodeSingularStringField(value: &_storage._displayError)
        case 5: try decoder.decodeSingularStringField(value: &_storage._label)
        case 6: try decoder.decodeSingularStringField(value: &_storage._name)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._options)
        case 8: try decoder.decodeSingularStringField(value: &_storage._pattern)
        case 9: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 11: try decoder.decodeSingularBoolField(value: &_storage._required)
        case 12: try decoder.decodeSingularBoolField(value: &_storage._readOnly)
        case 13: try decoder.decodeSingularStringField(value: &_storage._dependency)
        case 14: try decoder.decodeSingularStringField(value: &_storage._infoTitle)
        case 15: try decoder.decodeSingularStringField(value: &_storage._infoBody)
        case 16: try decoder.decodeSingularStringField(value: &_storage._introduction)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._defaultValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if let v = _storage._errors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._displayError.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayError, fieldNumber: 4)
      }
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 5)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 6)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._pattern.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pattern, fieldNumber: 8)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 9)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if _storage._required != false {
        try visitor.visitSingularBoolField(value: _storage._required, fieldNumber: 11)
      }
      if _storage._readOnly != false {
        try visitor.visitSingularBoolField(value: _storage._readOnly, fieldNumber: 12)
      }
      if !_storage._dependency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dependency, fieldNumber: 13)
      }
      if !_storage._infoTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._infoTitle, fieldNumber: 14)
      }
      if !_storage._infoBody.isEmpty {
        try visitor.visitSingularStringField(value: _storage._infoBody, fieldNumber: 15)
      }
      if !_storage._introduction.isEmpty {
        try visitor.visitSingularStringField(value: _storage._introduction, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationFormField, rhs: ApplicationFormField) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._defaultValue != rhs_storage._defaultValue {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._errors != rhs_storage._errors {return false}
        if _storage._displayError != rhs_storage._displayError {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._options != rhs_storage._options {return false}
        if _storage._pattern != rhs_storage._pattern {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._required != rhs_storage._required {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._dependency != rhs_storage._dependency {return false}
        if _storage._infoTitle != rhs_storage._infoTitle {return false}
        if _storage._infoBody != rhs_storage._infoBody {return false}
        if _storage._introduction != rhs_storage._introduction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationFormFieldOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationFormFieldOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationFormFieldOptions, rhs: ApplicationFormFieldOptions) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationFormFieldOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationFormFieldOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "label"),
    3: .same(proto: "description"),
    4: .standard(proto: "serialized_payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.value)
      case 2: try decoder.decodeSingularStringField(value: &self.label)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 4: try decoder.decodeSingularStringField(value: &self.serializedPayload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.serializedPayload.isEmpty {
      try visitor.visitSingularStringField(value: self.serializedPayload, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationFormFieldOption, rhs: ApplicationFormFieldOption) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.label != rhs.label {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.serializedPayload != rhs.serializedPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationFormFieldErrors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationFormFieldErrors"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.error)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationFormFieldErrors, rhs: ApplicationFormFieldErrors) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationFormFieldError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationFormFieldError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationFormFieldError, rhs: ApplicationFormFieldError) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "message"),
    3: .same(proto: "updated"),
  ]

  fileprivate class _StorageClass {
    var _key: ApplicationStatusKey = .applicationStatusUnknown
    var _message: String = String()
    var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _message = source._message
      _updated = source._updated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._key)
        case 2: try decoder.decodeSingularStringField(value: &_storage._message)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._updated)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._key != .applicationStatusUnknown {
        try visitor.visitSingularEnumField(value: _storage._key, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      if let v = _storage._updated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationStatus, rhs: ApplicationStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._updated != rhs_storage._updated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ApplicationFormStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ApplicationFormStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "message"),
    3: .same(proto: "updated"),
  ]

  fileprivate class _StorageClass {
    var _key: ApplicationFormStatusKey = .applicationFormStatusUnknown
    var _message: String = String()
    var _updated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _message = source._message
      _updated = source._updated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._key)
        case 2: try decoder.decodeSingularStringField(value: &_storage._message)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._updated)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._key != .applicationFormStatusUnknown {
        try visitor.visitSingularEnumField(value: _storage._key, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      if let v = _storage._updated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ApplicationFormStatus, rhs: ApplicationFormStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._updated != rhs_storage._updated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BusinessDays: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BusinessDays"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "days"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.year)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.month)
      case 3: try decoder.decodeRepeatedUInt32Field(value: &self.days)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    if !self.days.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.days, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BusinessDays, rhs: BusinessDays) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.days != rhs.days {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ErrorCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ErrorCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ErrorCode, rhs: ErrorCode) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Property: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Property"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "property_id"),
    2: .same(proto: "address"),
    3: .standard(proto: "postal_code"),
    4: .same(proto: "city"),
    5: .same(proto: "community"),
    6: .same(proto: "latitude"),
    7: .same(proto: "longitude"),
    8: .same(proto: "type"),
    9: .standard(proto: "number_of_rooms"),
    10: .standard(proto: "number_of_square_meters"),
    11: .same(proto: "valuation"),
    12: .standard(proto: "loan_account_ids"),
    13: .standard(proto: "registered_address"),
    14: .standard(proto: "user_modified_loan_account_ids"),
    15: .standard(proto: "valuation_amount"),
    16: .standard(proto: "total_loan_amount"),
    17: .standard(proto: "average_interest_rate"),
  ]

  fileprivate class _StorageClass {
    var _propertyID: String = String()
    var _address: String = String()
    var _postalCode: String = String()
    var _city: String = String()
    var _community: String = String()
    var _latitude: Double = 0
    var _longitude: Double = 0
    var _type: Property.TypeEnum = .propertyTypeUnknown
    var _numberOfRooms: Int32 = 0
    var _numberOfSquareMeters: Int32 = 0
    var _valuation: Int32 = 0
    var _loanAccountIds: [String] = []
    var _registeredAddress: Bool = false
    var _userModifiedLoanAccountIds: Bool = false
    var _valuationAmount: CurrencyDenominatedAmount? = nil
    var _totalLoanAmount: CurrencyDenominatedAmount? = nil
    var _averageInterestRate: ExactNumber? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _propertyID = source._propertyID
      _address = source._address
      _postalCode = source._postalCode
      _city = source._city
      _community = source._community
      _latitude = source._latitude
      _longitude = source._longitude
      _type = source._type
      _numberOfRooms = source._numberOfRooms
      _numberOfSquareMeters = source._numberOfSquareMeters
      _valuation = source._valuation
      _loanAccountIds = source._loanAccountIds
      _registeredAddress = source._registeredAddress
      _userModifiedLoanAccountIds = source._userModifiedLoanAccountIds
      _valuationAmount = source._valuationAmount
      _totalLoanAmount = source._totalLoanAmount
      _averageInterestRate = source._averageInterestRate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._propertyID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 3: try decoder.decodeSingularStringField(value: &_storage._postalCode)
        case 4: try decoder.decodeSingularStringField(value: &_storage._city)
        case 5: try decoder.decodeSingularStringField(value: &_storage._community)
        case 6: try decoder.decodeSingularDoubleField(value: &_storage._latitude)
        case 7: try decoder.decodeSingularDoubleField(value: &_storage._longitude)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 9: try decoder.decodeSingularInt32Field(value: &_storage._numberOfRooms)
        case 10: try decoder.decodeSingularInt32Field(value: &_storage._numberOfSquareMeters)
        case 11: try decoder.decodeSingularInt32Field(value: &_storage._valuation)
        case 12: try decoder.decodeRepeatedStringField(value: &_storage._loanAccountIds)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._registeredAddress)
        case 14: try decoder.decodeSingularBoolField(value: &_storage._userModifiedLoanAccountIds)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._valuationAmount)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._totalLoanAmount)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._averageInterestRate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._propertyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._propertyID, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if !_storage._postalCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._postalCode, fieldNumber: 3)
      }
      if !_storage._city.isEmpty {
        try visitor.visitSingularStringField(value: _storage._city, fieldNumber: 4)
      }
      if !_storage._community.isEmpty {
        try visitor.visitSingularStringField(value: _storage._community, fieldNumber: 5)
      }
      if _storage._latitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latitude, fieldNumber: 6)
      }
      if _storage._longitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._longitude, fieldNumber: 7)
      }
      if _storage._type != .propertyTypeUnknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 8)
      }
      if _storage._numberOfRooms != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numberOfRooms, fieldNumber: 9)
      }
      if _storage._numberOfSquareMeters != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numberOfSquareMeters, fieldNumber: 10)
      }
      if _storage._valuation != 0 {
        try visitor.visitSingularInt32Field(value: _storage._valuation, fieldNumber: 11)
      }
      if !_storage._loanAccountIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._loanAccountIds, fieldNumber: 12)
      }
      if _storage._registeredAddress != false {
        try visitor.visitSingularBoolField(value: _storage._registeredAddress, fieldNumber: 13)
      }
      if _storage._userModifiedLoanAccountIds != false {
        try visitor.visitSingularBoolField(value: _storage._userModifiedLoanAccountIds, fieldNumber: 14)
      }
      if let v = _storage._valuationAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._totalLoanAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._averageInterestRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Property, rhs: Property) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._propertyID != rhs_storage._propertyID {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._postalCode != rhs_storage._postalCode {return false}
        if _storage._city != rhs_storage._city {return false}
        if _storage._community != rhs_storage._community {return false}
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._numberOfRooms != rhs_storage._numberOfRooms {return false}
        if _storage._numberOfSquareMeters != rhs_storage._numberOfSquareMeters {return false}
        if _storage._valuation != rhs_storage._valuation {return false}
        if _storage._loanAccountIds != rhs_storage._loanAccountIds {return false}
        if _storage._registeredAddress != rhs_storage._registeredAddress {return false}
        if _storage._userModifiedLoanAccountIds != rhs_storage._userModifiedLoanAccountIds {return false}
        if _storage._valuationAmount != rhs_storage._valuationAmount {return false}
        if _storage._totalLoanAmount != rhs_storage._totalLoanAmount {return false}
        if _storage._averageInterestRate != rhs_storage._averageInterestRate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Property.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPERTY_TYPE_UNKNOWN"),
    1: .same(proto: "PROPERTY_TYPE_HOUSE"),
    2: .same(proto: "PROPERTY_TYPE_APARTMENT"),
    3: .same(proto: "PROPERTY_TYPE_VACATION_HOUSE"),
  ]
}

extension Market: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Market"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "label"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.label)
      case 3: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Market, rhs: Market) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.label != rhs.label {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProviderMarket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProviderMarket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProviderMarket, rhs: ProviderMarket) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PropertyValuationEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PropertyValuationEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "property_id"),
    2: .same(proto: "date"),
    3: .standard(proto: "valuation_amount"),
  ]

  fileprivate class _StorageClass {
    var _propertyID: String = String()
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _valuationAmount: CurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _propertyID = source._propertyID
      _date = source._date
      _valuationAmount = source._valuationAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._propertyID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._valuationAmount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._propertyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._propertyID, fieldNumber: 1)
      }
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._valuationAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PropertyValuationEvent, rhs: PropertyValuationEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._propertyID != rhs_storage._propertyID {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._valuationAmount != rhs_storage._valuationAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PropertyValuationSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PropertyValuationSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "property_id"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "from_valuation_amount"),
    5: .standard(proto: "to_valuation_amount"),
  ]

  fileprivate class _StorageClass {
    var _propertyID: String = String()
    var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _fromValuationAmount: CurrencyDenominatedAmount? = nil
    var _toValuationAmount: CurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _propertyID = source._propertyID
      _from = source._from
      _to = source._to
      _fromValuationAmount = source._fromValuationAmount
      _toValuationAmount = source._toValuationAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._propertyID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._from)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._to)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._fromValuationAmount)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._toValuationAmount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._propertyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._propertyID, fieldNumber: 1)
      }
      if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._to {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._fromValuationAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._toValuationAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PropertyValuationSummary, rhs: PropertyValuationSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._propertyID != rhs_storage._propertyID {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._fromValuationAmount != rhs_storage._fromValuationAmount {return false}
        if _storage._toValuationAmount != rhs_storage._toValuationAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Insight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Insight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "type"),
    4: .same(proto: "group"),
    5: .same(proto: "score"),
    6: .same(proto: "title"),
    7: .same(proto: "description"),
    8: .same(proto: "created"),
    9: .standard(proto: "expiration_date"),
    10: .standard(proto: "data_sets"),
    11: .same(proto: "actions"),
    12: .standard(proto: "reference_ids"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _userID: String = String()
    var _type: String = String()
    var _group: InsightGroup = .groupUnknown
    var _score: ExactNumber? = nil
    var _title: String = String()
    var _description_p: String = String()
    var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dataSets: [InsightDataSet] = []
    var _actions: [InsightAction] = []
    var _referenceIds: [ReferenceId] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _userID = source._userID
      _type = source._type
      _group = source._group
      _score = source._score
      _title = source._title
      _description_p = source._description_p
      _created = source._created
      _expirationDate = source._expirationDate
      _dataSets = source._dataSets
      _actions = source._actions
      _referenceIds = source._referenceIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._userID)
        case 3: try decoder.decodeSingularStringField(value: &_storage._type)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._group)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._score)
        case 6: try decoder.decodeSingularStringField(value: &_storage._title)
        case 7: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._created)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._expirationDate)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._dataSets)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._actions)
        case 12: try decoder.decodeRepeatedMessageField(value: &_storage._referenceIds)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 3)
      }
      if _storage._group != .groupUnknown {
        try visitor.visitSingularEnumField(value: _storage._group, fieldNumber: 4)
      }
      if let v = _storage._score {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 6)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 7)
      }
      if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._expirationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._dataSets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dataSets, fieldNumber: 10)
      }
      if !_storage._actions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actions, fieldNumber: 11)
      }
      if !_storage._referenceIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._referenceIds, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Insight, rhs: Insight) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._expirationDate != rhs_storage._expirationDate {return false}
        if _storage._dataSets != rhs_storage._dataSets {return false}
        if _storage._actions != rhs_storage._actions {return false}
        if _storage._referenceIds != rhs_storage._referenceIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArchivedInsight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ArchivedInsight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "type"),
    4: .same(proto: "group"),
    5: .same(proto: "score"),
    6: .same(proto: "title"),
    7: .same(proto: "description"),
    8: .standard(proto: "insight_created_date"),
    9: .standard(proto: "insight_archived_date"),
    10: .standard(proto: "data_sets"),
    11: .same(proto: "action"),
    12: .standard(proto: "reference_ids"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _userID: String = String()
    var _type: String = String()
    var _group: InsightGroup = .groupUnknown
    var _score: ExactNumber? = nil
    var _title: String = String()
    var _description_p: String = String()
    var _insightCreatedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _insightArchivedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dataSets: [InsightDataSet] = []
    var _action: InsightAction? = nil
    var _referenceIds: [ReferenceId] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _userID = source._userID
      _type = source._type
      _group = source._group
      _score = source._score
      _title = source._title
      _description_p = source._description_p
      _insightCreatedDate = source._insightCreatedDate
      _insightArchivedDate = source._insightArchivedDate
      _dataSets = source._dataSets
      _action = source._action
      _referenceIds = source._referenceIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._userID)
        case 3: try decoder.decodeSingularStringField(value: &_storage._type)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._group)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._score)
        case 6: try decoder.decodeSingularStringField(value: &_storage._title)
        case 7: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._insightCreatedDate)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._insightArchivedDate)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._dataSets)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._action)
        case 12: try decoder.decodeRepeatedMessageField(value: &_storage._referenceIds)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 3)
      }
      if _storage._group != .groupUnknown {
        try visitor.visitSingularEnumField(value: _storage._group, fieldNumber: 4)
      }
      if let v = _storage._score {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 6)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 7)
      }
      if let v = _storage._insightCreatedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._insightArchivedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._dataSets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dataSets, fieldNumber: 10)
      }
      if let v = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._referenceIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._referenceIds, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ArchivedInsight, rhs: ArchivedInsight) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._insightCreatedDate != rhs_storage._insightCreatedDate {return false}
        if _storage._insightArchivedDate != rhs_storage._insightArchivedDate {return false}
        if _storage._dataSets != rhs_storage._dataSets {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._referenceIds != rhs_storage._referenceIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightDataSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InsightDataSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "data_series"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.dataSeries)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.dataSeries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataSeries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightDataSet, rhs: InsightDataSet) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.dataSeries != rhs.dataSeries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightDataSet.DataSeries: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = InsightDataSet.protoMessageName + ".DataSeries"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "data_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.type)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.dataPoints)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightDataSet.DataSeries, rhs: InsightDataSet.DataSeries) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightDataSet.DataSeries.DataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = InsightDataSet.DataSeries.protoMessageName + ".DataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.x)
      case 2: try decoder.decodeSingularDoubleField(value: &self.y)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightDataSet.DataSeries.DataPoint, rhs: InsightDataSet.DataSeries.DataPoint) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InsightAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "target"),
    3: .same(proto: "type"),
    4: .same(proto: "method"),
    5: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.label)
      case 2: try decoder.decodeSingularStringField(value: &self.target)
      case 3: try decoder.decodeSingularEnumField(value: &self.type)
      case 4: try decoder.decodeSingularEnumField(value: &self.method)
      case 5: try decoder.decodeSingularEnumField(value: &self.group)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.method != .unknown {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 4)
    }
    if self.group != .groupUnknown {
      try visitor.visitSingularEnumField(value: self.group, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InsightAction, rhs: InsightAction) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.target != rhs.target {return false}
    if lhs.type != rhs.type {return false}
    if lhs.method != rhs.method {return false}
    if lhs.group != rhs.group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InsightAction.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_PRIMARY"),
    2: .same(proto: "TYPE_SECONDARY"),
  ]
}

extension InsightAction.Method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METHOD_UNKNOWN"),
    1: .same(proto: "METHOD_ACKNOWLEDGE"),
    2: .same(proto: "METHOD_CREATE"),
    3: .same(proto: "METHOD_ADD"),
    4: .same(proto: "METHOD_GO_TO"),
    5: .same(proto: "METHOD_EDIT"),
    6: .same(proto: "METHOD_NOT_NOW"),
    7: .same(proto: "METHOD_DISMISS"),
  ]
}

extension ReferenceId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ReferenceId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReferenceId, rhs: ReferenceId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReferenceId.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_ACCOUNT"),
    2: .same(proto: "TYPE_BUDGET"),
    3: .same(proto: "TYPE_CREDENTIALS"),
    4: .same(proto: "TYPE_SAVINGS_GOAL"),
    5: .same(proto: "TYPE_TRANSACTION"),
    6: .same(proto: "TYPE_TRANSFER"),
  ]
}

extension RecurringTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RecurringTransaction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RecurringTransaction, rhs: RecurringTransaction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RecurringTransaction.Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = RecurringTransaction.protoMessageName + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "type"),
    3: .same(proto: "date"),
    4: .same(proto: "description"),
    5: .same(proto: "amount"),
    6: .same(proto: "category"),
    7: .standard(proto: "group_id"),
    8: .same(proto: "source"),
  ]

  fileprivate class _StorageClass {
    var _transactionID: String = String()
    var _type: RecurringTransaction.Transaction.TypeEnum = .unknown
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _amount: CurrencyDenominatedAmount? = nil
    var _category: RecurringTransaction.Category? = nil
    var _groupID: String = String()
    var _source: RecurringTransaction.Transaction.Source = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionID = source._transactionID
      _type = source._type
      _date = source._date
      _description_p = source._description_p
      _amount = source._amount
      _category = source._category
      _groupID = source._groupID
      _source = source._source
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._transactionID)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 4: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._category)
        case 7: try decoder.decodeSingularStringField(value: &_storage._groupID)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._source)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transactionID, fieldNumber: 1)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._category {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._groupID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupID, fieldNumber: 7)
      }
      if _storage._source != .unknown {
        try visitor.visitSingularEnumField(value: _storage._source, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RecurringTransaction.Transaction, rhs: RecurringTransaction.Transaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._source != rhs_storage._source {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RecurringTransaction.Transaction.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_PREDICTED"),
    2: .same(proto: "TYPE_EXISTING"),
  ]
}

extension RecurringTransaction.Transaction.Source: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_USER_ADDED"),
    2: .same(proto: "SOURCE_GENERATED"),
  ]
}

extension RecurringTransaction.Category: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = RecurringTransaction.protoMessageName + ".Category"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "code"),
    3: .standard(proto: "primary_name"),
    4: .standard(proto: "secondary_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.code)
      case 3: try decoder.decodeSingularStringField(value: &self.primaryName)
      case 4: try decoder.decodeSingularStringField(value: &self.secondaryName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 2)
    }
    if !self.primaryName.isEmpty {
      try visitor.visitSingularStringField(value: self.primaryName, fieldNumber: 3)
    }
    if !self.secondaryName.isEmpty {
      try visitor.visitSingularStringField(value: self.secondaryName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RecurringTransaction.Category, rhs: RecurringTransaction.Category) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.code != rhs.code {return false}
    if lhs.primaryName != rhs.primaryName {return false}
    if lhs.secondaryName != rhs.secondaryName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RecurringTransaction.Category.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_INCOME"),
    2: .same(proto: "TYPE_EXPENSE"),
    3: .same(proto: "TYPE_TRANSFER"),
  ]
}

extension RecurringTransaction.Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = RecurringTransaction.protoMessageName + ".Group"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "qualifier"),
    4: .same(proto: "periodicity"),
    5: .standard(proto: "category_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.qualifier)
      case 4: try decoder.decodeSingularEnumField(value: &self.periodicity)
      case 5: try decoder.decodeSingularEnumField(value: &self.categoryType)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.qualifier.isEmpty {
      try visitor.visitSingularStringField(value: self.qualifier, fieldNumber: 3)
    }
    if self.periodicity != .unknown {
      try visitor.visitSingularEnumField(value: self.periodicity, fieldNumber: 4)
    }
    if self.categoryType != .unknown {
      try visitor.visitSingularEnumField(value: self.categoryType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RecurringTransaction.Group, rhs: RecurringTransaction.Group) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.qualifier != rhs.qualifier {return false}
    if lhs.periodicity != rhs.periodicity {return false}
    if lhs.categoryType != rhs.categoryType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RecurringTransaction.Group.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNKNOWN"),
    1: .same(proto: "STATE_DISABLED"),
    2: .same(proto: "STATE_ACTIVE"),
  ]
}

extension RecurringTransaction.Group.RecurringPeriodicity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RECURRING_PERIODICITY_UNKNOWN"),
    1: .same(proto: "RECURRING_PERIODICITY_MONTHLY"),
    2: .same(proto: "RECURRING_PERIODICITY_QUARTERLY"),
    3: .same(proto: "RECURRING_PERIODICITY_YEARLY"),
  ]
}

extension RecurringTransaction.PeriodSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = RecurringTransaction.protoMessageName + ".PeriodSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_amount"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
  ]

  fileprivate class _StorageClass {
    var _totalAmount: CurrencyDenominatedAmount? = nil
    var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _totalAmount = source._totalAmount
      _start = source._start
      _end = source._end
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._totalAmount)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._start)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._end)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._totalAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._start {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._end {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RecurringTransaction.PeriodSummary, rhs: RecurringTransaction.PeriodSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._totalAmount != rhs_storage._totalAmount {return false}
        if _storage._start != rhs_storage._start {return false}
        if _storage._end != rhs_storage._end {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KycQuestion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "KycQuestion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reference"),
    2: .same(proto: "answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.reference)
      case 2: try decoder.decodeSingularStringField(value: &self.answer)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reference.isEmpty {
      try visitor.visitSingularStringField(value: self.reference, fieldNumber: 1)
    }
    if !self.answer.isEmpty {
      try visitor.visitSingularStringField(value: self.answer, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: KycQuestion, rhs: KycQuestion) -> Bool {
    if lhs.reference != rhs.reference {return false}
    if lhs.answer != rhs.answer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
