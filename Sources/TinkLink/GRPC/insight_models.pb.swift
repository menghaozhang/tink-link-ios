// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: insight_models.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct GRPCInsights {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var insights: [GRPCInsight] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GRPCInsight {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdTime = newValue}
  }
  /// Returns true if `createdTime` has been explicitly set.
  var hasCreatedTime: Bool {return _storage._createdTime != nil}
  /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
  mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

  var data: GRPCInsightData {
    get {return _storage._data ?? GRPCInsightData()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  var actions: [GRPCInsightAction] {
    get {return _storage._actions}
    set {_uniqueStorage()._actions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GRPCArchivedInsight {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdTime = newValue}
  }
  /// Returns true if `createdTime` has been explicitly set.
  var hasCreatedTime: Bool {return _storage._createdTime != nil}
  /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
  mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

  var archivedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._archivedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._archivedTime = newValue}
  }
  /// Returns true if `archivedTime` has been explicitly set.
  var hasArchivedTime: Bool {return _storage._archivedTime != nil}
  /// Clears the value of `archivedTime`. Subsequent reads from it will return its default value.
  mutating func clearArchivedTime() {_uniqueStorage()._archivedTime = nil}

  var data: GRPCInsightData {
    get {return _storage._data ?? GRPCInsightData()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GRPCInsightData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var accountBalanceLow: GRPCInsightData.DataMessage.AccountBalanceLow {
    get {
      if case .accountBalanceLow(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.AccountBalanceLow()
    }
    set {_uniqueStorage()._data = .accountBalanceLow(newValue)}
  }

  var budgetSuccess: GRPCInsightData.DataMessage.BudgetSuccess {
    get {
      if case .budgetSuccess(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.BudgetSuccess()
    }
    set {_uniqueStorage()._data = .budgetSuccess(newValue)}
  }

  var budgetOverspent: GRPCInsightData.DataMessage.BudgetOverspent {
    get {
      if case .budgetOverspent(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.BudgetOverspent()
    }
    set {_uniqueStorage()._data = .budgetOverspent(newValue)}
  }

  var budgetSummaryAchieved: GRPCInsightData.DataMessage.BudgetSummaryAchieved {
    get {
      if case .budgetSummaryAchieved(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.BudgetSummaryAchieved()
    }
    set {_uniqueStorage()._data = .budgetSummaryAchieved(newValue)}
  }

  var budgetSummaryOverspent: GRPCInsightData.DataMessage.BudgetSummaryOverspent {
    get {
      if case .budgetSummaryOverspent(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.BudgetSummaryOverspent()
    }
    set {_uniqueStorage()._data = .budgetSummaryOverspent(newValue)}
  }

  var budgetClosePositive: GRPCInsightData.DataMessage.BudgetClosePositive {
    get {
      if case .budgetClosePositive(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.BudgetClosePositive()
    }
    set {_uniqueStorage()._data = .budgetClosePositive(newValue)}
  }

  var budgetCloseNegative: GRPCInsightData.DataMessage.BudgetCloseNegative {
    get {
      if case .budgetCloseNegative(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.BudgetCloseNegative()
    }
    set {_uniqueStorage()._data = .budgetCloseNegative(newValue)}
  }

  var largeExpense: GRPCInsightData.DataMessage.LargeExpense {
    get {
      if case .largeExpense(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.LargeExpense()
    }
    set {_uniqueStorage()._data = .largeExpense(newValue)}
  }

  var doubleCharge: GRPCInsightData.DataMessage.DoubleCharge {
    get {
      if case .doubleCharge(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.DoubleCharge()
    }
    set {_uniqueStorage()._data = .doubleCharge(newValue)}
  }

  var singleUncategorizedExpense: GRPCInsightData.DataMessage.SingleUncategorizedExpense {
    get {
      if case .singleUncategorizedExpense(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.SingleUncategorizedExpense()
    }
    set {_uniqueStorage()._data = .singleUncategorizedExpense(newValue)}
  }

  var weeklyUncategorizedTransactions: GRPCInsightData.DataMessage.WeeklyUncategorizedTransactions {
    get {
      if case .weeklyUncategorizedTransactions(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.WeeklyUncategorizedTransactions()
    }
    set {_uniqueStorage()._data = .weeklyUncategorizedTransactions(newValue)}
  }

  var weeklyExpensesByCategory: GRPCInsightData.DataMessage.WeeklyExpensesByCategory {
    get {
      if case .weeklyExpensesByCategory(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.WeeklyExpensesByCategory()
    }
    set {_uniqueStorage()._data = .weeklyExpensesByCategory(newValue)}
  }

  var weeklyExpensesByDay: GRPCInsightData.DataMessage.WeeklyExpensesByDay {
    get {
      if case .weeklyExpensesByDay(let v)? = _storage._data {return v}
      return GRPCInsightData.DataMessage.WeeklyExpensesByDay()
    }
    set {_uniqueStorage()._data = .weeklyExpensesByDay(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case accountBalanceLow(GRPCInsightData.DataMessage.AccountBalanceLow)
    case budgetSuccess(GRPCInsightData.DataMessage.BudgetSuccess)
    case budgetOverspent(GRPCInsightData.DataMessage.BudgetOverspent)
    case budgetSummaryAchieved(GRPCInsightData.DataMessage.BudgetSummaryAchieved)
    case budgetSummaryOverspent(GRPCInsightData.DataMessage.BudgetSummaryOverspent)
    case budgetClosePositive(GRPCInsightData.DataMessage.BudgetClosePositive)
    case budgetCloseNegative(GRPCInsightData.DataMessage.BudgetCloseNegative)
    case largeExpense(GRPCInsightData.DataMessage.LargeExpense)
    case doubleCharge(GRPCInsightData.DataMessage.DoubleCharge)
    case singleUncategorizedExpense(GRPCInsightData.DataMessage.SingleUncategorizedExpense)
    case weeklyUncategorizedTransactions(GRPCInsightData.DataMessage.WeeklyUncategorizedTransactions)
    case weeklyExpensesByCategory(GRPCInsightData.DataMessage.WeeklyExpensesByCategory)
    case weeklyExpensesByDay(GRPCInsightData.DataMessage.WeeklyExpensesByDay)

  #if !swift(>=4.1)
    static func ==(lhs: GRPCInsightData.OneOf_Data, rhs: GRPCInsightData.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.accountBalanceLow(let l), .accountBalanceLow(let r)): return l == r
      case (.budgetSuccess(let l), .budgetSuccess(let r)): return l == r
      case (.budgetOverspent(let l), .budgetOverspent(let r)): return l == r
      case (.budgetSummaryAchieved(let l), .budgetSummaryAchieved(let r)): return l == r
      case (.budgetSummaryOverspent(let l), .budgetSummaryOverspent(let r)): return l == r
      case (.budgetClosePositive(let l), .budgetClosePositive(let r)): return l == r
      case (.budgetCloseNegative(let l), .budgetCloseNegative(let r)): return l == r
      case (.largeExpense(let l), .largeExpense(let r)): return l == r
      case (.doubleCharge(let l), .doubleCharge(let r)): return l == r
      case (.singleUncategorizedExpense(let l), .singleUncategorizedExpense(let r)): return l == r
      case (.weeklyUncategorizedTransactions(let l), .weeklyUncategorizedTransactions(let r)): return l == r
      case (.weeklyExpensesByCategory(let l), .weeklyExpensesByCategory(let r)): return l == r
      case (.weeklyExpensesByDay(let l), .weeklyExpensesByDay(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  struct DataMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct AccountBalanceLow {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var accountID: String {
        get {return _storage._accountID}
        set {_uniqueStorage()._accountID = newValue}
      }

      var balance: GRPCCurrencyDenominatedAmount {
        get {return _storage._balance ?? GRPCCurrencyDenominatedAmount()}
        set {_uniqueStorage()._balance = newValue}
      }
      /// Returns true if `balance` has been explicitly set.
      var hasBalance: Bool {return _storage._balance != nil}
      /// Clears the value of `balance`. Subsequent reads from it will return its default value.
      mutating func clearBalance() {_uniqueStorage()._balance = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct BudgetSuccess {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var budgetID: String {
        get {return _storage._budgetID}
        set {_uniqueStorage()._budgetID = newValue}
      }

      var budgetPeriod: GRPCBudget.Period {
        get {return _storage._budgetPeriod ?? GRPCBudget.Period()}
        set {_uniqueStorage()._budgetPeriod = newValue}
      }
      /// Returns true if `budgetPeriod` has been explicitly set.
      var hasBudgetPeriod: Bool {return _storage._budgetPeriod != nil}
      /// Clears the value of `budgetPeriod`. Subsequent reads from it will return its default value.
      mutating func clearBudgetPeriod() {_uniqueStorage()._budgetPeriod = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct BudgetOverspent {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var budgetID: String {
        get {return _storage._budgetID}
        set {_uniqueStorage()._budgetID = newValue}
      }

      var budgetPeriod: GRPCBudget.Period {
        get {return _storage._budgetPeriod ?? GRPCBudget.Period()}
        set {_uniqueStorage()._budgetPeriod = newValue}
      }
      /// Returns true if `budgetPeriod` has been explicitly set.
      var hasBudgetPeriod: Bool {return _storage._budgetPeriod != nil}
      /// Clears the value of `budgetPeriod`. Subsequent reads from it will return its default value.
      mutating func clearBudgetPeriod() {_uniqueStorage()._budgetPeriod = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct BudgetSummaryAchieved {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var achievedBudgets: [GRPCInsightData.DataMessage.BudgetSummary] {
        get {return _storage._achievedBudgets}
        set {_uniqueStorage()._achievedBudgets = newValue}
      }

      var overspentBudgets: [GRPCInsightData.DataMessage.BudgetSummary] {
        get {return _storage._overspentBudgets}
        set {_uniqueStorage()._overspentBudgets = newValue}
      }

      var savedAmount: GRPCCurrencyDenominatedAmount {
        get {return _storage._savedAmount ?? GRPCCurrencyDenominatedAmount()}
        set {_uniqueStorage()._savedAmount = newValue}
      }
      /// Returns true if `savedAmount` has been explicitly set.
      var hasSavedAmount: Bool {return _storage._savedAmount != nil}
      /// Clears the value of `savedAmount`. Subsequent reads from it will return its default value.
      mutating func clearSavedAmount() {_uniqueStorage()._savedAmount = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct BudgetSummaryOverspent {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var achievedBudgets: [GRPCInsightData.DataMessage.BudgetSummary] {
        get {return _storage._achievedBudgets}
        set {_uniqueStorage()._achievedBudgets = newValue}
      }

      var overspentBudgets: [GRPCInsightData.DataMessage.BudgetSummary] {
        get {return _storage._overspentBudgets}
        set {_uniqueStorage()._overspentBudgets = newValue}
      }

      var overspentAmount: GRPCCurrencyDenominatedAmount {
        get {return _storage._overspentAmount ?? GRPCCurrencyDenominatedAmount()}
        set {_uniqueStorage()._overspentAmount = newValue}
      }
      /// Returns true if `overspentAmount` has been explicitly set.
      var hasOverspentAmount: Bool {return _storage._overspentAmount != nil}
      /// Clears the value of `overspentAmount`. Subsequent reads from it will return its default value.
      mutating func clearOverspentAmount() {_uniqueStorage()._overspentAmount = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct BudgetClosePositive {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var budgetID: String {
        get {return _storage._budgetID}
        set {_uniqueStorage()._budgetID = newValue}
      }

      var budgetPeriod: GRPCBudget.Period {
        get {return _storage._budgetPeriod ?? GRPCBudget.Period()}
        set {_uniqueStorage()._budgetPeriod = newValue}
      }
      /// Returns true if `budgetPeriod` has been explicitly set.
      var hasBudgetPeriod: Bool {return _storage._budgetPeriod != nil}
      /// Clears the value of `budgetPeriod`. Subsequent reads from it will return its default value.
      mutating func clearBudgetPeriod() {_uniqueStorage()._budgetPeriod = nil}

      var currentTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _storage._currentTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_uniqueStorage()._currentTime = newValue}
      }
      /// Returns true if `currentTime` has been explicitly set.
      var hasCurrentTime: Bool {return _storage._currentTime != nil}
      /// Clears the value of `currentTime`. Subsequent reads from it will return its default value.
      mutating func clearCurrentTime() {_uniqueStorage()._currentTime = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct BudgetCloseNegative {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var budgetID: String {
        get {return _storage._budgetID}
        set {_uniqueStorage()._budgetID = newValue}
      }

      var budgetPeriod: GRPCBudget.Period {
        get {return _storage._budgetPeriod ?? GRPCBudget.Period()}
        set {_uniqueStorage()._budgetPeriod = newValue}
      }
      /// Returns true if `budgetPeriod` has been explicitly set.
      var hasBudgetPeriod: Bool {return _storage._budgetPeriod != nil}
      /// Clears the value of `budgetPeriod`. Subsequent reads from it will return its default value.
      mutating func clearBudgetPeriod() {_uniqueStorage()._budgetPeriod = nil}

      var currentTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _storage._currentTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_uniqueStorage()._currentTime = newValue}
      }
      /// Returns true if `currentTime` has been explicitly set.
      var hasCurrentTime: Bool {return _storage._currentTime != nil}
      /// Clears the value of `currentTime`. Subsequent reads from it will return its default value.
      mutating func clearCurrentTime() {_uniqueStorage()._currentTime = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct BudgetSummary {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var budgetID: String {
        get {return _storage._budgetID}
        set {_uniqueStorage()._budgetID = newValue}
      }

      var budgetPeriod: GRPCBudget.Period {
        get {return _storage._budgetPeriod ?? GRPCBudget.Period()}
        set {_uniqueStorage()._budgetPeriod = newValue}
      }
      /// Returns true if `budgetPeriod` has been explicitly set.
      var hasBudgetPeriod: Bool {return _storage._budgetPeriod != nil}
      /// Clears the value of `budgetPeriod`. Subsequent reads from it will return its default value.
      mutating func clearBudgetPeriod() {_uniqueStorage()._budgetPeriod = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct LargeExpense {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transactionID: String {
        get {return _storage._transactionID}
        set {_uniqueStorage()._transactionID = newValue}
      }

      var amount: GRPCCurrencyDenominatedAmount {
        get {return _storage._amount ?? GRPCCurrencyDenominatedAmount()}
        set {_uniqueStorage()._amount = newValue}
      }
      /// Returns true if `amount` has been explicitly set.
      var hasAmount: Bool {return _storage._amount != nil}
      /// Clears the value of `amount`. Subsequent reads from it will return its default value.
      mutating func clearAmount() {_uniqueStorage()._amount = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct DoubleCharge {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transactionIds: [String] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct SingleUncategorizedExpense {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transactionID: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct WeeklyUncategorizedTransactions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transactionIds: [String] = []

      var week: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct WeeklyExpensesByCategory {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var week: GRPCYearWeek {
        get {return _storage._week ?? GRPCYearWeek()}
        set {_uniqueStorage()._week = newValue}
      }
      /// Returns true if `week` has been explicitly set.
      var hasWeek: Bool {return _storage._week != nil}
      /// Clears the value of `week`. Subsequent reads from it will return its default value.
      mutating func clearWeek() {_uniqueStorage()._week = nil}

      var spendingByCategory: [GRPCInsightData.DataMessage.WeeklyExpensesByCategory.CategorySpending] {
        get {return _storage._spendingByCategory}
        set {_uniqueStorage()._spendingByCategory = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct CategorySpending {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var categoryID: String {
          get {return _storage._categoryID}
          set {_uniqueStorage()._categoryID = newValue}
        }

        var amount: GRPCCurrencyDenominatedAmount {
          get {return _storage._amount ?? GRPCCurrencyDenominatedAmount()}
          set {_uniqueStorage()._amount = newValue}
        }
        /// Returns true if `amount` has been explicitly set.
        var hasAmount: Bool {return _storage._amount != nil}
        /// Clears the value of `amount`. Subsequent reads from it will return its default value.
        mutating func clearAmount() {_uniqueStorage()._amount = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct WeeklyExpensesByDay {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var week: GRPCYearWeek {
        get {return _storage._week ?? GRPCYearWeek()}
        set {_uniqueStorage()._week = newValue}
      }
      /// Returns true if `week` has been explicitly set.
      var hasWeek: Bool {return _storage._week != nil}
      /// Clears the value of `week`. Subsequent reads from it will return its default value.
      mutating func clearWeek() {_uniqueStorage()._week = nil}

      var expenseStatisticsByDay: [GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatisticsByDay] {
        get {return _storage._expenseStatisticsByDay}
        set {_uniqueStorage()._expenseStatisticsByDay = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct ExpenseStatisticsByDay {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var date: Google_Type_Date {
          get {return _storage._date ?? Google_Type_Date()}
          set {_uniqueStorage()._date = newValue}
        }
        /// Returns true if `date` has been explicitly set.
        var hasDate: Bool {return _storage._date != nil}
        /// Clears the value of `date`. Subsequent reads from it will return its default value.
        mutating func clearDate() {_uniqueStorage()._date = nil}

        var expenseStatistics: GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatistics {
          get {return _storage._expenseStatistics ?? GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatistics()}
          set {_uniqueStorage()._expenseStatistics = newValue}
        }
        /// Returns true if `expenseStatistics` has been explicitly set.
        var hasExpenseStatistics: Bool {return _storage._expenseStatistics != nil}
        /// Clears the value of `expenseStatistics`. Subsequent reads from it will return its default value.
        mutating func clearExpenseStatistics() {_uniqueStorage()._expenseStatistics = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
      }

      struct ExpenseStatistics {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var totalAmount: GRPCCurrencyDenominatedAmount {
          get {return _storage._totalAmount ?? GRPCCurrencyDenominatedAmount()}
          set {_uniqueStorage()._totalAmount = newValue}
        }
        /// Returns true if `totalAmount` has been explicitly set.
        var hasTotalAmount: Bool {return _storage._totalAmount != nil}
        /// Clears the value of `totalAmount`. Subsequent reads from it will return its default value.
        mutating func clearTotalAmount() {_uniqueStorage()._totalAmount = nil}

        var averageAmount: GRPCCurrencyDenominatedAmount {
          get {return _storage._averageAmount ?? GRPCCurrencyDenominatedAmount()}
          set {_uniqueStorage()._averageAmount = newValue}
        }
        /// Returns true if `averageAmount` has been explicitly set.
        var hasAverageAmount: Bool {return _storage._averageAmount != nil}
        /// Clears the value of `averageAmount`. Subsequent reads from it will return its default value.
        mutating func clearAverageAmount() {_uniqueStorage()._averageAmount = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GRPCInsightAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String {
    get {return _storage._label}
    set {_uniqueStorage()._label = newValue}
  }

  var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var acknowledge: GRPCInsightAction.DataMessage.Acknowledge {
    get {
      if case .acknowledge(let v)? = _storage._data {return v}
      return GRPCInsightAction.DataMessage.Acknowledge()
    }
    set {_uniqueStorage()._data = .acknowledge(newValue)}
  }

  var dismiss: GRPCInsightAction.DataMessage.Dismiss {
    get {
      if case .dismiss(let v)? = _storage._data {return v}
      return GRPCInsightAction.DataMessage.Dismiss()
    }
    set {_uniqueStorage()._data = .dismiss(newValue)}
  }

  var viewBudget: GRPCInsightAction.DataMessage.ViewBudget {
    get {
      if case .viewBudget(let v)? = _storage._data {return v}
      return GRPCInsightAction.DataMessage.ViewBudget()
    }
    set {_uniqueStorage()._data = .viewBudget(newValue)}
  }

  var createTransfer: GRPCInsightAction.DataMessage.CreateTransfer {
    get {
      if case .createTransfer(let v)? = _storage._data {return v}
      return GRPCInsightAction.DataMessage.CreateTransfer()
    }
    set {_uniqueStorage()._data = .createTransfer(newValue)}
  }

  var viewTransaction: GRPCInsightAction.DataMessage.ViewTransaction {
    get {
      if case .viewTransaction(let v)? = _storage._data {return v}
      return GRPCInsightAction.DataMessage.ViewTransaction()
    }
    set {_uniqueStorage()._data = .viewTransaction(newValue)}
  }

  var categorizeSingleExpense: GRPCInsightAction.DataMessage.CategorizeSingleExpense {
    get {
      if case .categorizeSingleExpense(let v)? = _storage._data {return v}
      return GRPCInsightAction.DataMessage.CategorizeSingleExpense()
    }
    set {_uniqueStorage()._data = .categorizeSingleExpense(newValue)}
  }

  var viewTransactions: GRPCInsightAction.DataMessage.ViewTransactions {
    get {
      if case .viewTransactions(let v)? = _storage._data {return v}
      return GRPCInsightAction.DataMessage.ViewTransactions()
    }
    set {_uniqueStorage()._data = .viewTransactions(newValue)}
  }

  var categorizeTransactions: GRPCInsightAction.DataMessage.CategorizeTransactions {
    get {
      if case .categorizeTransactions(let v)? = _storage._data {return v}
      return GRPCInsightAction.DataMessage.CategorizeTransactions()
    }
    set {_uniqueStorage()._data = .categorizeTransactions(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case acknowledge(GRPCInsightAction.DataMessage.Acknowledge)
    case dismiss(GRPCInsightAction.DataMessage.Dismiss)
    case viewBudget(GRPCInsightAction.DataMessage.ViewBudget)
    case createTransfer(GRPCInsightAction.DataMessage.CreateTransfer)
    case viewTransaction(GRPCInsightAction.DataMessage.ViewTransaction)
    case categorizeSingleExpense(GRPCInsightAction.DataMessage.CategorizeSingleExpense)
    case viewTransactions(GRPCInsightAction.DataMessage.ViewTransactions)
    case categorizeTransactions(GRPCInsightAction.DataMessage.CategorizeTransactions)

  #if !swift(>=4.1)
    static func ==(lhs: GRPCInsightAction.OneOf_Data, rhs: GRPCInsightAction.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.acknowledge(let l), .acknowledge(let r)): return l == r
      case (.dismiss(let l), .dismiss(let r)): return l == r
      case (.viewBudget(let l), .viewBudget(let r)): return l == r
      case (.createTransfer(let l), .createTransfer(let r)): return l == r
      case (.viewTransaction(let l), .viewTransaction(let r)): return l == r
      case (.categorizeSingleExpense(let l), .categorizeSingleExpense(let r)): return l == r
      case (.viewTransactions(let l), .viewTransactions(let r)): return l == r
      case (.categorizeTransactions(let l), .categorizeTransactions(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  struct DataMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Acknowledge {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Dismiss {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ViewBudget {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var budgetID: String {
        get {return _storage._budgetID}
        set {_uniqueStorage()._budgetID = newValue}
      }

      var budgetPeriodStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {return _storage._budgetPeriodStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_uniqueStorage()._budgetPeriodStartTime = newValue}
      }
      /// Returns true if `budgetPeriodStartTime` has been explicitly set.
      var hasBudgetPeriodStartTime: Bool {return _storage._budgetPeriodStartTime != nil}
      /// Clears the value of `budgetPeriodStartTime`. Subsequent reads from it will return its default value.
      mutating func clearBudgetPeriodStartTime() {_uniqueStorage()._budgetPeriodStartTime = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct ViewTransaction {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transactionID: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct CreateTransfer {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var sourceAccountUri: String {
        get {return _storage._sourceAccountUri}
        set {_uniqueStorage()._sourceAccountUri = newValue}
      }

      var destinationAccountUri: String {
        get {return _storage._destinationAccountUri}
        set {_uniqueStorage()._destinationAccountUri = newValue}
      }

      var amount: GRPCCurrencyDenominatedAmount {
        get {return _storage._amount ?? GRPCCurrencyDenominatedAmount()}
        set {_uniqueStorage()._amount = newValue}
      }
      /// Returns true if `amount` has been explicitly set.
      var hasAmount: Bool {return _storage._amount != nil}
      /// Clears the value of `amount`. Subsequent reads from it will return its default value.
      mutating func clearAmount() {_uniqueStorage()._amount = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct CategorizeSingleExpense {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transactionID: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ViewTransactions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transactionIds: [String] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct CategorizeTransactions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transactionIds: [String] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct GRPCYearWeek {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var year: Int32 = 0

  var week: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension GRPCInsights: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Insights"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "insights"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.insights)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.insights.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insights, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsights, rhs: GRPCInsights) -> Bool {
    if lhs.insights != rhs.insights {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Insight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .same(proto: "description"),
    5: .standard(proto: "created_time"),
    6: .same(proto: "data"),
    7: .same(proto: "actions"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: String = String()
    var _title: String = String()
    var _description_p: String = String()
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _data: GRPCInsightData? = nil
    var _actions: [GRPCInsightAction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _title = source._title
      _description_p = source._description_p
      _createdTime = source._createdTime
      _data = source._data
      _actions = source._actions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._type)
        case 3: try decoder.decodeSingularStringField(value: &_storage._title)
        case 4: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._createdTime)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._data)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._actions)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._actions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actions, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsight, rhs: GRPCInsight) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._actions != rhs_storage._actions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCArchivedInsight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ArchivedInsight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .same(proto: "description"),
    5: .standard(proto: "created_time"),
    6: .standard(proto: "archived_time"),
    7: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: String = String()
    var _title: String = String()
    var _description_p: String = String()
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _archivedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _data: GRPCInsightData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _title = source._title
      _description_p = source._description_p
      _createdTime = source._createdTime
      _archivedTime = source._archivedTime
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._type)
        case 3: try decoder.decodeSingularStringField(value: &_storage._title)
        case 4: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._createdTime)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._archivedTime)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._archivedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCArchivedInsight, rhs: GRPCArchivedInsight) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._archivedTime != rhs_storage._archivedTime {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InsightData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_balance_low"),
    2: .standard(proto: "budget_success"),
    3: .standard(proto: "budget_overspent"),
    4: .standard(proto: "budget_summary_achieved"),
    5: .standard(proto: "budget_summary_overspent"),
    6: .standard(proto: "budget_close_positive"),
    7: .standard(proto: "budget_close_negative"),
    8: .standard(proto: "large_expense"),
    9: .standard(proto: "double_charge"),
    10: .standard(proto: "single_uncategorized_expense"),
    11: .standard(proto: "weekly_uncategorized_transactions"),
    12: .standard(proto: "weekly_expenses_by_category"),
    13: .standard(proto: "weekly_expenses_by_day"),
  ]

  fileprivate class _StorageClass {
    var _data: GRPCInsightData.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: GRPCInsightData.DataMessage.AccountBalanceLow?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .accountBalanceLow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .accountBalanceLow(v)}
        case 2:
          var v: GRPCInsightData.DataMessage.BudgetSuccess?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .budgetSuccess(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .budgetSuccess(v)}
        case 3:
          var v: GRPCInsightData.DataMessage.BudgetOverspent?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .budgetOverspent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .budgetOverspent(v)}
        case 4:
          var v: GRPCInsightData.DataMessage.BudgetSummaryAchieved?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .budgetSummaryAchieved(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .budgetSummaryAchieved(v)}
        case 5:
          var v: GRPCInsightData.DataMessage.BudgetSummaryOverspent?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .budgetSummaryOverspent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .budgetSummaryOverspent(v)}
        case 6:
          var v: GRPCInsightData.DataMessage.BudgetClosePositive?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .budgetClosePositive(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .budgetClosePositive(v)}
        case 7:
          var v: GRPCInsightData.DataMessage.BudgetCloseNegative?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .budgetCloseNegative(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .budgetCloseNegative(v)}
        case 8:
          var v: GRPCInsightData.DataMessage.LargeExpense?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .largeExpense(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .largeExpense(v)}
        case 9:
          var v: GRPCInsightData.DataMessage.DoubleCharge?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .doubleCharge(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .doubleCharge(v)}
        case 10:
          var v: GRPCInsightData.DataMessage.SingleUncategorizedExpense?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .singleUncategorizedExpense(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .singleUncategorizedExpense(v)}
        case 11:
          var v: GRPCInsightData.DataMessage.WeeklyUncategorizedTransactions?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .weeklyUncategorizedTransactions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .weeklyUncategorizedTransactions(v)}
        case 12:
          var v: GRPCInsightData.DataMessage.WeeklyExpensesByCategory?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .weeklyExpensesByCategory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .weeklyExpensesByCategory(v)}
        case 13:
          var v: GRPCInsightData.DataMessage.WeeklyExpensesByDay?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .weeklyExpensesByDay(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .weeklyExpensesByDay(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._data {
      case .accountBalanceLow(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .budgetSuccess(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .budgetOverspent(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .budgetSummaryAchieved(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .budgetSummaryOverspent(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .budgetClosePositive(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .budgetCloseNegative(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .largeExpense(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .doubleCharge(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .singleUncategorizedExpense(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .weeklyUncategorizedTransactions(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .weeklyExpensesByCategory(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .weeklyExpensesByDay(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData, rhs: GRPCInsightData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.protoMessageName + ".Data"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage, rhs: GRPCInsightData.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.AccountBalanceLow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".AccountBalanceLow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .same(proto: "balance"),
  ]

  fileprivate class _StorageClass {
    var _accountID: String = String()
    var _balance: GRPCCurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _balance = source._balance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._accountID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._balance)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 1)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.AccountBalanceLow, rhs: GRPCInsightData.DataMessage.AccountBalanceLow) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._balance != rhs_storage._balance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.BudgetSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".BudgetSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "budget_id"),
    2: .standard(proto: "budget_period"),
  ]

  fileprivate class _StorageClass {
    var _budgetID: String = String()
    var _budgetPeriod: GRPCBudget.Period? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _budgetID = source._budgetID
      _budgetPeriod = source._budgetPeriod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._budgetID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._budgetPeriod)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._budgetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._budgetID, fieldNumber: 1)
      }
      if let v = _storage._budgetPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.BudgetSuccess, rhs: GRPCInsightData.DataMessage.BudgetSuccess) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._budgetID != rhs_storage._budgetID {return false}
        if _storage._budgetPeriod != rhs_storage._budgetPeriod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.BudgetOverspent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".BudgetOverspent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "budget_id"),
    2: .standard(proto: "budget_period"),
  ]

  fileprivate class _StorageClass {
    var _budgetID: String = String()
    var _budgetPeriod: GRPCBudget.Period? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _budgetID = source._budgetID
      _budgetPeriod = source._budgetPeriod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._budgetID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._budgetPeriod)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._budgetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._budgetID, fieldNumber: 1)
      }
      if let v = _storage._budgetPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.BudgetOverspent, rhs: GRPCInsightData.DataMessage.BudgetOverspent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._budgetID != rhs_storage._budgetID {return false}
        if _storage._budgetPeriod != rhs_storage._budgetPeriod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.BudgetSummaryAchieved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".BudgetSummaryAchieved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "achieved_budgets"),
    2: .standard(proto: "overspent_budgets"),
    3: .standard(proto: "saved_amount"),
  ]

  fileprivate class _StorageClass {
    var _achievedBudgets: [GRPCInsightData.DataMessage.BudgetSummary] = []
    var _overspentBudgets: [GRPCInsightData.DataMessage.BudgetSummary] = []
    var _savedAmount: GRPCCurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _achievedBudgets = source._achievedBudgets
      _overspentBudgets = source._overspentBudgets
      _savedAmount = source._savedAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._achievedBudgets)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._overspentBudgets)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._savedAmount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._achievedBudgets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._achievedBudgets, fieldNumber: 1)
      }
      if !_storage._overspentBudgets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._overspentBudgets, fieldNumber: 2)
      }
      if let v = _storage._savedAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.BudgetSummaryAchieved, rhs: GRPCInsightData.DataMessage.BudgetSummaryAchieved) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._achievedBudgets != rhs_storage._achievedBudgets {return false}
        if _storage._overspentBudgets != rhs_storage._overspentBudgets {return false}
        if _storage._savedAmount != rhs_storage._savedAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.BudgetSummaryOverspent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".BudgetSummaryOverspent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "achieved_budgets"),
    2: .standard(proto: "overspent_budgets"),
    3: .standard(proto: "overspent_amount"),
  ]

  fileprivate class _StorageClass {
    var _achievedBudgets: [GRPCInsightData.DataMessage.BudgetSummary] = []
    var _overspentBudgets: [GRPCInsightData.DataMessage.BudgetSummary] = []
    var _overspentAmount: GRPCCurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _achievedBudgets = source._achievedBudgets
      _overspentBudgets = source._overspentBudgets
      _overspentAmount = source._overspentAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._achievedBudgets)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._overspentBudgets)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._overspentAmount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._achievedBudgets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._achievedBudgets, fieldNumber: 1)
      }
      if !_storage._overspentBudgets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._overspentBudgets, fieldNumber: 2)
      }
      if let v = _storage._overspentAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.BudgetSummaryOverspent, rhs: GRPCInsightData.DataMessage.BudgetSummaryOverspent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._achievedBudgets != rhs_storage._achievedBudgets {return false}
        if _storage._overspentBudgets != rhs_storage._overspentBudgets {return false}
        if _storage._overspentAmount != rhs_storage._overspentAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.BudgetClosePositive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".BudgetClosePositive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "budget_id"),
    2: .standard(proto: "budget_period"),
    3: .standard(proto: "current_time"),
  ]

  fileprivate class _StorageClass {
    var _budgetID: String = String()
    var _budgetPeriod: GRPCBudget.Period? = nil
    var _currentTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _budgetID = source._budgetID
      _budgetPeriod = source._budgetPeriod
      _currentTime = source._currentTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._budgetID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._budgetPeriod)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._currentTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._budgetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._budgetID, fieldNumber: 1)
      }
      if let v = _storage._budgetPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._currentTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.BudgetClosePositive, rhs: GRPCInsightData.DataMessage.BudgetClosePositive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._budgetID != rhs_storage._budgetID {return false}
        if _storage._budgetPeriod != rhs_storage._budgetPeriod {return false}
        if _storage._currentTime != rhs_storage._currentTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.BudgetCloseNegative: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".BudgetCloseNegative"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "budget_id"),
    2: .standard(proto: "budget_period"),
    3: .standard(proto: "current_time"),
  ]

  fileprivate class _StorageClass {
    var _budgetID: String = String()
    var _budgetPeriod: GRPCBudget.Period? = nil
    var _currentTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _budgetID = source._budgetID
      _budgetPeriod = source._budgetPeriod
      _currentTime = source._currentTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._budgetID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._budgetPeriod)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._currentTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._budgetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._budgetID, fieldNumber: 1)
      }
      if let v = _storage._budgetPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._currentTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.BudgetCloseNegative, rhs: GRPCInsightData.DataMessage.BudgetCloseNegative) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._budgetID != rhs_storage._budgetID {return false}
        if _storage._budgetPeriod != rhs_storage._budgetPeriod {return false}
        if _storage._currentTime != rhs_storage._currentTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.BudgetSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".BudgetSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "budget_id"),
    2: .standard(proto: "budget_period"),
  ]

  fileprivate class _StorageClass {
    var _budgetID: String = String()
    var _budgetPeriod: GRPCBudget.Period? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _budgetID = source._budgetID
      _budgetPeriod = source._budgetPeriod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._budgetID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._budgetPeriod)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._budgetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._budgetID, fieldNumber: 1)
      }
      if let v = _storage._budgetPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.BudgetSummary, rhs: GRPCInsightData.DataMessage.BudgetSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._budgetID != rhs_storage._budgetID {return false}
        if _storage._budgetPeriod != rhs_storage._budgetPeriod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.LargeExpense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".LargeExpense"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _transactionID: String = String()
    var _amount: GRPCCurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionID = source._transactionID
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._transactionID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transactionID, fieldNumber: 1)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.LargeExpense, rhs: GRPCInsightData.DataMessage.LargeExpense) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._amount != rhs_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.DoubleCharge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".DoubleCharge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.transactionIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.DoubleCharge, rhs: GRPCInsightData.DataMessage.DoubleCharge) -> Bool {
    if lhs.transactionIds != rhs.transactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.SingleUncategorizedExpense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".SingleUncategorizedExpense"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.transactionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.SingleUncategorizedExpense, rhs: GRPCInsightData.DataMessage.SingleUncategorizedExpense) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.WeeklyUncategorizedTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".WeeklyUncategorizedTransactions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_ids"),
    2: .same(proto: "week"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.transactionIds)
      case 2: try decoder.decodeSingularInt32Field(value: &self.week)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 1)
    }
    if self.week != 0 {
      try visitor.visitSingularInt32Field(value: self.week, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.WeeklyUncategorizedTransactions, rhs: GRPCInsightData.DataMessage.WeeklyUncategorizedTransactions) -> Bool {
    if lhs.transactionIds != rhs.transactionIds {return false}
    if lhs.week != rhs.week {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.WeeklyExpensesByCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".WeeklyExpensesByCategory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "week"),
    2: .standard(proto: "spending_by_category"),
  ]

  fileprivate class _StorageClass {
    var _week: GRPCYearWeek? = nil
    var _spendingByCategory: [GRPCInsightData.DataMessage.WeeklyExpensesByCategory.CategorySpending] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _week = source._week
      _spendingByCategory = source._spendingByCategory
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._week)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._spendingByCategory)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._week {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._spendingByCategory.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._spendingByCategory, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.WeeklyExpensesByCategory, rhs: GRPCInsightData.DataMessage.WeeklyExpensesByCategory) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._week != rhs_storage._week {return false}
        if _storage._spendingByCategory != rhs_storage._spendingByCategory {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.WeeklyExpensesByCategory.CategorySpending: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.WeeklyExpensesByCategory.protoMessageName + ".CategorySpending"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "category_id"),
    2: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _categoryID: String = String()
    var _amount: GRPCCurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _categoryID = source._categoryID
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._categoryID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._categoryID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._categoryID, fieldNumber: 1)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.WeeklyExpensesByCategory.CategorySpending, rhs: GRPCInsightData.DataMessage.WeeklyExpensesByCategory.CategorySpending) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._categoryID != rhs_storage._categoryID {return false}
        if _storage._amount != rhs_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.WeeklyExpensesByDay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.protoMessageName + ".WeeklyExpensesByDay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "week"),
    2: .standard(proto: "expense_statistics_by_day"),
  ]

  fileprivate class _StorageClass {
    var _week: GRPCYearWeek? = nil
    var _expenseStatisticsByDay: [GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatisticsByDay] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _week = source._week
      _expenseStatisticsByDay = source._expenseStatisticsByDay
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._week)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._expenseStatisticsByDay)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._week {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._expenseStatisticsByDay.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expenseStatisticsByDay, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.WeeklyExpensesByDay, rhs: GRPCInsightData.DataMessage.WeeklyExpensesByDay) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._week != rhs_storage._week {return false}
        if _storage._expenseStatisticsByDay != rhs_storage._expenseStatisticsByDay {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatisticsByDay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.WeeklyExpensesByDay.protoMessageName + ".ExpenseStatisticsByDay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .standard(proto: "expense_statistics"),
  ]

  fileprivate class _StorageClass {
    var _date: Google_Type_Date? = nil
    var _expenseStatistics: GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatistics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _date = source._date
      _expenseStatistics = source._expenseStatistics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._date)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._expenseStatistics)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._expenseStatistics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatisticsByDay, rhs: GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatisticsByDay) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._date != rhs_storage._date {return false}
        if _storage._expenseStatistics != rhs_storage._expenseStatistics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightData.DataMessage.WeeklyExpensesByDay.protoMessageName + ".ExpenseStatistics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_amount"),
    2: .standard(proto: "average_amount"),
  ]

  fileprivate class _StorageClass {
    var _totalAmount: GRPCCurrencyDenominatedAmount? = nil
    var _averageAmount: GRPCCurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _totalAmount = source._totalAmount
      _averageAmount = source._averageAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._totalAmount)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._averageAmount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._totalAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._averageAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatistics, rhs: GRPCInsightData.DataMessage.WeeklyExpensesByDay.ExpenseStatistics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._totalAmount != rhs_storage._totalAmount {return false}
        if _storage._averageAmount != rhs_storage._averageAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InsightAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "acknowledge"),
    3: .same(proto: "dismiss"),
    4: .standard(proto: "view_budget"),
    5: .standard(proto: "create_transfer"),
    6: .standard(proto: "view_transaction"),
    7: .standard(proto: "categorize_single_expense"),
    8: .standard(proto: "view_transactions"),
    9: .standard(proto: "categorize_transactions"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _data: GRPCInsightAction.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2:
          var v: GRPCInsightAction.DataMessage.Acknowledge?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .acknowledge(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .acknowledge(v)}
        case 3:
          var v: GRPCInsightAction.DataMessage.Dismiss?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .dismiss(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .dismiss(v)}
        case 4:
          var v: GRPCInsightAction.DataMessage.ViewBudget?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .viewBudget(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .viewBudget(v)}
        case 5:
          var v: GRPCInsightAction.DataMessage.CreateTransfer?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .createTransfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .createTransfer(v)}
        case 6:
          var v: GRPCInsightAction.DataMessage.ViewTransaction?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .viewTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .viewTransaction(v)}
        case 7:
          var v: GRPCInsightAction.DataMessage.CategorizeSingleExpense?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .categorizeSingleExpense(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .categorizeSingleExpense(v)}
        case 8:
          var v: GRPCInsightAction.DataMessage.ViewTransactions?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .viewTransactions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .viewTransactions(v)}
        case 9:
          var v: GRPCInsightAction.DataMessage.CategorizeTransactions?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .categorizeTransactions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .categorizeTransactions(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      switch _storage._data {
      case .acknowledge(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .dismiss(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .viewBudget(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .createTransfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .viewTransaction(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .categorizeSingleExpense(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .viewTransactions(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .categorizeTransactions(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction, rhs: GRPCInsightAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightAction.protoMessageName + ".Data"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction.DataMessage, rhs: GRPCInsightAction.DataMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction.DataMessage.Acknowledge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightAction.DataMessage.protoMessageName + ".Acknowledge"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction.DataMessage.Acknowledge, rhs: GRPCInsightAction.DataMessage.Acknowledge) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction.DataMessage.Dismiss: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightAction.DataMessage.protoMessageName + ".Dismiss"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction.DataMessage.Dismiss, rhs: GRPCInsightAction.DataMessage.Dismiss) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction.DataMessage.ViewBudget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightAction.DataMessage.protoMessageName + ".ViewBudget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "budget_id"),
    2: .standard(proto: "budget_period_start_time"),
  ]

  fileprivate class _StorageClass {
    var _budgetID: String = String()
    var _budgetPeriodStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _budgetID = source._budgetID
      _budgetPeriodStartTime = source._budgetPeriodStartTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._budgetID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._budgetPeriodStartTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._budgetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._budgetID, fieldNumber: 1)
      }
      if let v = _storage._budgetPeriodStartTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction.DataMessage.ViewBudget, rhs: GRPCInsightAction.DataMessage.ViewBudget) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._budgetID != rhs_storage._budgetID {return false}
        if _storage._budgetPeriodStartTime != rhs_storage._budgetPeriodStartTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction.DataMessage.ViewTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightAction.DataMessage.protoMessageName + ".ViewTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.transactionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction.DataMessage.ViewTransaction, rhs: GRPCInsightAction.DataMessage.ViewTransaction) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction.DataMessage.CreateTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightAction.DataMessage.protoMessageName + ".CreateTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_account_uri"),
    2: .standard(proto: "destination_account_uri"),
    3: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _sourceAccountUri: String = String()
    var _destinationAccountUri: String = String()
    var _amount: GRPCCurrencyDenominatedAmount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sourceAccountUri = source._sourceAccountUri
      _destinationAccountUri = source._destinationAccountUri
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._sourceAccountUri)
        case 2: try decoder.decodeSingularStringField(value: &_storage._destinationAccountUri)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._sourceAccountUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourceAccountUri, fieldNumber: 1)
      }
      if !_storage._destinationAccountUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._destinationAccountUri, fieldNumber: 2)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction.DataMessage.CreateTransfer, rhs: GRPCInsightAction.DataMessage.CreateTransfer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sourceAccountUri != rhs_storage._sourceAccountUri {return false}
        if _storage._destinationAccountUri != rhs_storage._destinationAccountUri {return false}
        if _storage._amount != rhs_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction.DataMessage.CategorizeSingleExpense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightAction.DataMessage.protoMessageName + ".CategorizeSingleExpense"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.transactionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction.DataMessage.CategorizeSingleExpense, rhs: GRPCInsightAction.DataMessage.CategorizeSingleExpense) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction.DataMessage.ViewTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightAction.DataMessage.protoMessageName + ".ViewTransactions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.transactionIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction.DataMessage.ViewTransactions, rhs: GRPCInsightAction.DataMessage.ViewTransactions) -> Bool {
    if lhs.transactionIds != rhs.transactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCInsightAction.DataMessage.CategorizeTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = GRPCInsightAction.DataMessage.protoMessageName + ".CategorizeTransactions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.transactionIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCInsightAction.DataMessage.CategorizeTransactions, rhs: GRPCInsightAction.DataMessage.CategorizeTransactions) -> Bool {
    if lhs.transactionIds != rhs.transactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GRPCYearWeek: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "YearWeek"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "week"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.year)
      case 2: try decoder.decodeSingularInt32Field(value: &self.week)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.week != 0 {
      try visitor.visitSingularInt32Field(value: self.week, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GRPCYearWeek, rhs: GRPCYearWeek) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.week != rhs.week {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
